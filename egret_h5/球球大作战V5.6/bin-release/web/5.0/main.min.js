var __reflect = (this && this.__reflect) || function (p, c, t) {
    p.__class__ = c, t ? t.push(c) : t = [c], p.__types__ = p.__types__ ? t.concat(p.__types__) : t;
};
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * 球刺精灵，可以实例化地图的球刺
 */
var Thorn = (function (_super) {
    __extends(Thorn, _super);
    function Thorn(r, kindName) {
        var _this = _super.call(this) || this;
        //球刺生命
        _this.isLive = false;
        _this.weight = 0;
        //球刺颜色列表
        _this.colorList = [13408665, 16777113, 6710937, 6710937, 16750848, 16776960, 39372, 13421721, 13382553, 10079232, 16737894, 16776960, 3381708, 13395456];
        _this.init(r, kindName);
        return _this;
    }
    //球刺数据初始化
    Thorn.prototype.init = function (r, kindName) {
        this.radius = r;
        this.shape = new egret.Shape();
        this.weight = this.radius ^ 3;
        this.distance = r;
        //this.bulk = 3.14 * this.radius * this.radius;
        this.thornName = kindName;
        this.color = this.colorList[Math.floor(Math.random() * this.colorList.length)];
        this.shape.graphics.beginFill(this.color);
        if (kindName == "circle")
            this.shape.graphics.drawCircle(0, 0, r);
        else if (kindName == "rect")
            this.shape.graphics.drawRect(0, 0, 2 * r, 2 * r);
        this.shape.graphics.endFill();
        this.isLive = true;
        this.addChild(this.shape);
        this.skin = new egret.Bitmap(RES.getRes("ci_png"));
        this.skin.width = this.skin.height = r * 2;
        this.skin.anchorOffsetX = r;
        this.skin.anchorOffsetY = r;
        this.addChild(this.skin);
        //this.shape.x = px;
        //this.shape.y = py;
    };
    //球刺生产
    Thorn.produce = function (r, kindName) {
        if (Thorn.cacheThorn[kindName] == null)
            Thorn.cacheThorn[kindName] = [];
        var tempThornArr = Thorn.cacheThorn[kindName];
        var thorn;
        if (tempThornArr.length > 0) {
            thorn = tempThornArr.pop();
            thorn.isLive = true;
        }
        else
            thorn = new Thorn(r, kindName);
        return thorn;
    };
    //球刺回收
    Thorn.reclaim = function (thorn, kindName) {
        if (Thorn.cacheThorn[kindName] == null)
            Thorn.cacheThorn[kindName] = [];
        var tempThornArr = Thorn.cacheThorn[kindName];
        if (tempThornArr.indexOf(thorn) == -1)
            tempThornArr.push(thorn);
    };
    return Thorn;
}(egret.Sprite));
/**
 * 球刺对象池
 */
Thorn.cacheThorn = {};
__reflect(Thorn.prototype, "Thorn");
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-present, Egret Technology.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var AssetAdapter = (function () {
    function AssetAdapter() {
    }
    /**
     * @language zh_CN
     * 解析素材
     * @param source 待解析的新素材标识符
     * @param compFunc 解析完成回调函数，示例：callBack(content:any,source:string):void;
     * @param thisObject callBack的 this 引用
     */
    AssetAdapter.prototype.getAsset = function (source, compFunc, thisObject) {
        function onGetRes(data) {
            compFunc.call(thisObject, data, source);
        }
        if (RES.hasRes(source)) {
            var data = RES.getRes(source);
            if (data) {
                onGetRes(data);
            }
            else {
                RES.getResAsync(source, onGetRes, this);
            }
        }
        else {
            RES.getResByUrl(source, onGetRes, this, RES.ResourceItem.TYPE_IMAGE);
        }
    };
    return AssetAdapter;
}());
__reflect(AssetAdapter.prototype, "AssetAdapter", ["eui.IAssetAdapter"]);
/**
 * 球球精灵对象，可实例化为我方球球、NPC球球
 */
var Circle = (function (_super) {
    __extends(Circle, _super);
    function Circle(r, kindName, color, name) {
        var _this = _super.call(this) || this;
        //小球生命
        _this.isLive = false;
        //球球缓存半径
        _this.cacheRadius = 0;
        _this.cacheWeight = 0;
        _this.weight = 0;
        //可选颜色列表
        _this.colorList = [13408665, 16777113, 6710937, 6710937, 16750848, 16776960, 39372, 13421721, 13382553, 10079232, 16737894, 16776960, 3381708, 13395456];
        _this.init(r, kindName, color, name);
        return _this;
    }
    /**
     * 小球数据初始化
     */
    Circle.prototype.init = function (weight, kindName, color, name) {
        this.isFilter = false;
        this.shape = new egret.Shape();
        this.weight = weight;
        this.radius = Math.pow(this.weight, 1 / 3);
        this.bulk = this.radius;
        this.speed = 3;
        this.cirName = kindName;
        this.stance = 0.8 * (15 / this.radius);
        this.name = name;
        this.swallowed = 0;
        this.color = color;
        if (color == 16776960)
            this.color = this.colorList[Math.floor(Math.random() * this.colorList.length)];
        this.isLive = true;
        this.shape.graphics.beginFill(this.color);
        this.shape.graphics.drawCircle(0, 0, this.radius);
        this.shape.graphics.endFill();
        //this.shape.x = px;
        //this.shape.y = py;
        //this.isLive = true;
        this.addChild(this.shape);
        //我方球球添加皮肤
        if (this.cirName == "myCirclr") {
            this.skin = new egret.Bitmap(RES.getRes("form1_png"));
            this.skin.width = this.skin.height = this.radius * 2;
            this.skin.anchorOffsetX = this.radius;
            this.skin.anchorOffsetY = this.radius;
            this.addChild(this.skin);
            this.skinName = "form1_png";
        }
        //我方球球添加名字
        this.nameText = new egret.TextField();
        this.nameText.text = this.name;
        this.nameText.textColor = 0xffffff;
        this.nameText.size = 12;
        // this.nameText.x = GameManager.stage.stageWidth /2 - 200;
        // this.nameText.y = GameManager.stage.stageHeight /2 - 230; 
        this.nameText.x = -this.nameText.width / 2;
        this.nameText.y = -this.nameText.height / 2;
        this.addChild(this.nameText);
    };
    //生产对象
    Circle.produce = function (weight, kindName, color, name) {
        if (Circle.cacheCircle[kindName] == null)
            Circle.cacheCircle[kindName] = [];
        var tempCirArr = Circle.cacheCircle[kindName];
        var circle;
        if (tempCirArr.length > 0) {
            circle = tempCirArr.pop();
            if (kindName == "myCirclr") {
                circle.weight = weight;
                circle.radius = Math.pow(circle.weight, 1 / 3);
                circle.color = color;
                circle.name = name;
                circle.skin.width = circle.skin.height = circle.radius * 2;
                circle.skin.anchorOffsetX = circle.radius;
                circle.skin.anchorOffsetY = circle.radius;
                circle.shape.graphics.clear();
                circle.shape.graphics.beginFill(circle.color);
                circle.shape.graphics.drawCircle(0, 0, circle.radius);
                circle.shape.graphics.endFill();
            }
            circle.isLive = true;
        }
        else
            circle = new Circle(weight, kindName, color, name);
        return circle;
    };
    //回收对象
    Circle.reclaim = function (circle, kindName) {
        if (Circle.cacheCircle[kindName] == null)
            Circle.cacheCircle[kindName] = [];
        var tempCirArr = Circle.cacheCircle[kindName];
        if (tempCirArr.indexOf(circle) == -1) {
            tempCirArr.push(circle);
        }
    };
    return Circle;
}(egret.Sprite));
/**
 * 球球对象池
 */
Circle.cacheCircle = {};
__reflect(Circle.prototype, "Circle");
// TypeScript file
var GameControl = (function (_super) {
    __extends(GameControl, _super);
    function GameControl() {
        var _this = _super.call(this) || this;
        //控制点flag
        _this.controlFlag = false;
        //控制盘大小
        _this.conBgSize = 50;
        //世界地图边缘碰撞检测标志
        _this.mapRightFlag = [false];
        _this.mapLeftFlag = [false];
        _this.mapTopFlag = [false];
        _this.mapBottomFlag = [false];
        _this.myCirArr = LayerManager.game.myCirArr;
        _this.gameBackGround = LayerManager.game.gameBackGround;
        _this.bootAlgea = LayerManager.game.bootAlgea;
        _this.bootCirArr = LayerManager.game.bootCirArr;
        _this.bootThorn = LayerManager.game.bootThorn;
        _this.mySporeArr = LayerManager.game.mySpornArr;
        //我方球球碰撞检测在分裂时期是否开启（正常情况： 分裂的时候不开启碰撞检测）
        _this.splitHitTest = true;
        _this.spornHitTest = true;
        _this.offsetLocalX = 0;
        _this.offsetLocalY = 0;
        //名字容器
        _this.rankingArr = [];
        //游戏时间
        _this.timeTotal = 180;
        _this.init();
        return _this;
    }
    GameControl.prototype.init = function () {
        /**
         * 初始化控制盘
         */
        this.control_bg = new egret.Shape();
        this.control_bg.graphics.beginFill(0xffffff, 0.2);
        this.control_bg.graphics.drawCircle(0, 0, this.conBgSize);
        this.control_bg.graphics.endFill();
        //this.con_bg.anchorOffsetX = 50;
        //this.con_bg.anchorOffsetY = 50;
        //this.control_bg.x = 120;
        //this.control_bg.y = 360;
        this.control_bg.touchEnabled = true;
        //this.addChild(this.control_bg);
        /**
         * 初始化控制点
         */
        this.control_ball = new egret.Shape();
        this.control_ball.graphics.beginFill(0xff0011, 0.5);
        this.control_ball.graphics.drawCircle(0, 0, 15);
        this.control_ball.graphics.endFill();
        //this.con_ball.anchorOffsetX = 7.5;
        //this.con_ball.anchorOffsetY = 7.5;
        //this.control_ball.x = 120;
        //this.control_ball.y = 360;
        //this.addChild(this.control_ball);
        /**
         * 控制盘侦听
         */
        LayerManager.game.addEventListener(egret.TouchEvent.TOUCH_MOVE, this.onTouch, this);
        LayerManager.game.addEventListener(egret.TouchEvent.TOUCH_END, this.touchEnd, this);
        /**
         * 创建分数区
         */
        this.myCirBulk = new egret.TextField();
        this.myCirBulk.text = "当前体积：";
        this.myCirBulk.textColor = 0xffffff;
        this.myCirBulk.size = 12;
        this.myCirBulk.x = GameManager.stage.stageWidth / 2 - 350;
        this.myCirBulk.y = GameManager.stage.stageHeight / 2 - 230;
        this.addChild(this.myCirBulk);
        /**
         * 创建分裂按钮
         *
         */
        this.splitArea = new egret.Shape();
        this.splitArea.graphics.beginFill(0xffffff, 0.2);
        this.splitArea.graphics.drawCircle(0, 0, 25);
        this.splitArea.graphics.endFill();
        this.splitArea.x = GameManager.stage.$stageWidth - 160;
        this.splitArea.y = GameManager.stage.$stageHeight - 45;
        this.splitArea.touchEnabled = true;
        this.addChild(this.splitArea);
        this.splitArea.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onSplit, this);
        /**
         * 创建吐孢子按钮
         *
         */
        this.spornArea = new egret.Shape();
        this.spornArea.graphics.beginFill(0xffffff, 0.2);
        this.spornArea.graphics.drawCircle(0, 0, 30);
        this.spornArea.graphics.endFill();
        this.spornArea.x = GameManager.stage.$stageWidth - 90;
        this.spornArea.y = GameManager.stage.$stageHeight - 50;
        this.spornArea.touchEnabled = true;
        this.addChild(this.spornArea);
        this.spornArea.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onSpore, this);
        /**
         * 创建排行榜区
         *
         */
        this.rankingArea = new egret.Shape();
        this.rankingArea.graphics.beginFill(0x000000, 0.2);
        this.rankingArea.graphics.drawRect(0, 0, 150, 160);
        this.rankingArea.graphics.endFill();
        this.rankingArea.x = 650;
        this.addChild(this.rankingArea);
        //名字初始化
        var j = 0;
        this.NO1 = this.initName(this.NO1);
        this.NO2 = this.initName(this.NO2);
        this.NO3 = this.initName(this.NO3);
        this.NO4 = this.initName(this.NO4);
        this.NO5 = this.initName(this.NO5);
        this.NO6 = this.initName(this.NO6);
        this.NO7 = this.initName(this.NO7);
        this.NO8 = this.initName(this.NO8);
        this.NO9 = this.initName(this.NO9);
        this.NO10 = this.initName(this.NO10);
        /**
         * 名字容器赋值，分配到排行榜
         *
         */
        var i = 0;
        for (i = 0; i < 10; i++) {
            if (i == 0) {
                this.rankingArr.push(LayerManager.welcome.myCirName);
            }
            else {
                if (LayerManager.game.bootCirArr[i - 1].name != undefined)
                    this.rankingArr.push(LayerManager.game.bootCirArr[i - 1].name);
            }
        }
        this.NO1.text = "1   " + this.rankingArr[0];
        this.NO1.x = 670;
        this.NO1.y = 5;
        this.NO2.text = "2   " + this.rankingArr[1];
        this.NO2.x = 670;
        this.NO2.y = 20;
        this.NO3.text = "3   " + this.rankingArr[2];
        this.NO3.x = 670;
        this.NO3.y = 35;
        this.NO4.text = "4   " + this.rankingArr[3];
        this.NO4.x = 670;
        this.NO4.y = 50;
        this.NO5.text = "5   " + this.rankingArr[4];
        this.NO5.x = 670;
        this.NO5.y = 65;
        this.NO6.text = "6   " + this.rankingArr[5];
        this.NO6.x = 670;
        this.NO6.y = 80;
        this.NO7.text = "7   " + this.rankingArr[6];
        this.NO7.x = 670;
        this.NO7.y = 95;
        this.NO8.text = "8   " + this.rankingArr[7];
        this.NO8.x = 670;
        this.NO8.y = 110;
        this.NO9.text = "9   " + this.rankingArr[8];
        this.NO9.x = 670;
        this.NO9.y = 125;
        this.NO10.text = "10   " + this.rankingArr[9];
        this.NO10.x = 662;
        this.NO10.y = 140;
        /**
         *定时解除我方球球碰撞
         *
         */
        this.spliteHitTimer = new egret.Timer(600, 1);
        this.spliteHitTimer.addEventListener(egret.TimerEvent.TIMER_COMPLETE, this.changeSplitStatus, this); //定时将在点击分裂按钮后开启，功能是将碰撞检测重新打开
        /**
         *
         * 定时解除我方孢子碰撞
         *
         */
        this.spornHitTimer = new egret.Timer(500, 1);
        this.spornHitTimer.addEventListener(egret.TimerEvent.TIMER_COMPLETE, this.changeSpornStatus, this);
        /**
         *
         * 初始化游戏时长显示文本
         *
         */
        this.timeText = new egret.TextField();
        this.timeText.text = this.changeTime();
        this.timeText.textColor = 0xffffff;
        this.timeText.size = 16;
        this.timeText.x = 400 - this.timeText.width / 2;
        this.timeText.y = 10;
        //console.log(this.timeText.text);
        this.addChild(this.timeText);
        /**
         * 初始化游戏时长
         */
        this.gameTimer = new egret.Timer(1000, this.timeTotal);
        this.gameTimer.addEventListener(egret.TimerEvent.TIMER, this.onRefresh, this);
        this.gameTimer.addEventListener(egret.TimerEvent.TIMER_COMPLETE, this.gameover, this);
        this.gameTimer.start();
    };
    /**
     *
     * 游戏时长转换
     *
     */
    GameControl.prototype.changeTime = function () {
        var second = this.timeTotal % 60;
        var min = parseInt((this.timeTotal / 60).toString());
        var resultTimeText;
        if (min < 10 && second < 10) {
            resultTimeText = "0" + min + ":" + "0" + second;
        }
        else if (min < 10 && second >= 10) {
            resultTimeText = "0" + min + ":" + second;
        }
        else if (min >= 10 && second < 10) {
            resultTimeText = min + ":" + "0" + second;
        }
        //  console.log(typeof(second));
        //  console.log(second);
        return resultTimeText;
    };
    /**
     *
     * 每秒刷新剩余时间
     *
     */
    GameControl.prototype.onRefresh = function () {
        this.timeTotal -= 1;
        //console.log(this.timeTotal);
        this.timeText.text = this.changeTime();
    };
    /**
     * 时间到游戏结束
     *
     */
    GameControl.prototype.gameover = function () {
        LayerManager.onTouch2();
    };
    /**
     *
     * 名字初始化工厂
     *
     */
    GameControl.prototype.initName = function (needInitName) {
        needInitName = new egret.TextField();
        // needInitName.text = "当前体积：";
        needInitName.textColor = 0xffffff;
        needInitName.size = 14;
        // needInitName.x = GameManager.stage.stageWidth /2 - 200;
        // needInitName.y = GameManager.stage.stageHeight /2 - 230; 
        this.addChild(needInitName);
        return needInitName;
    };
    /**
     * 碰撞检测开关
     *
     */
    GameControl.prototype.changeSplitStatus = function () {
        this.splitHitTest = true;
        this.spliteHitTimer.stop();
    };
    /**
     * 另外一个开关
     *
     */
    GameControl.prototype.changeSpornStatus = function () {
        this.spornHitTest = true;
        this.spornHitTimer.stop();
    };
    /**
     * 我方球球位移由控制点控制
     *
     */
    GameControl.prototype.move = function (event) {
        var stance = 3; //步长
        var j;
        var i;
        var cir;
        var algea;
        var myCir;
        var thorn;
        var spore;
        //重绘、缩放与位移都需要判定最大的球球
        var maxRadius = 0;
        for (j = 0; j < this.myCirArr.length; j++) {
            //由每个小球来确定自己的速度
            //this.myCirArr[j].stance = this.myCirArr[j].speed * (1- (this.myCirArr[j].radius - this.myCirR)/1000);
            this.myCirArr[j].stance = 0.8 * (15 / this.myCirArr[j].radius); //半径约小，速度越大
            if (this.myCirArr[j].radius > maxRadius) {
                maxRadius = this.myCirArr[j].radius;
                myCir = this.myCirArr[j];
            }
        }
        //更新每个球球的边界flag
        this.mapHitTest(this.myCirArr);
        /**
         * 世界地图的移速是以我方最大的小球的移速决定
         * 其余移速慢的小球不靠世界地图位移来展示
         * 而是有小球自己运动叠加运动效果来显示较快的移速
         *
         */
        //console.log(this.X,this.Y,this.control_X,this.control_Y)
        //通过判断控制盘的坐标，来操作我的小球的运动方向
        if (this.X > this.control_X && this.Y < this.control_Y) {
            //判断我方球球任意一个小球是否出世界地图
            if (this.returnResult("right", this.myCirArr)) {
                //我方球球不动  触碰的那个小球不动
                //this.gameBackGround.x = - (this.gameBackGround.width - GameManager.stage.stageWidth /2 - myCir.radius);
                //其他的小球继续运动，并且是小球运动，而不是世界地图运动
                //我方最大球球移动  地图移动
                //检测出已碰到边界的小球，不予操作（不动），其他小球则运动（世界地图停止运动，小球运动，最大球根据stance，小球根据自己的stance）
                for (i = 0; i < this.myCirArr.length; i++) {
                    if (this.mapRightFlag[i] == false) {
                        if (this.myCirArr[i] == myCir)
                            this.myCirArr[i].x += Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * (stance);
                        else
                            this.myCirArr[i].x += Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[i].stance;
                    }
                    else { }
                }
            }
            else {
                //我方所有小球移动 
                this.gameBackGround.x -= Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                //除最大球之外，小球相对于摄像机也在移动
                for (j = 0; j < this.myCirArr.length; j++) {
                    if (this.myCirArr[j] != myCir) {
                        this.myCirArr[j].x += Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[j].stance;
                    }
                }
                //改成世界地图容器移动，地图、浮游物、刺、NPC都不需单独移动，但是我方球球不需要移动，因为移动容器就是想让我方球球看起来在移动，所以这里因该在容器移动的基础再反方向移动，这样球球其实就是不动的
                //for( j  = 0 ; j < this.myCirArr.length ; j ++){
                //        this.myCirArr[j].x += Math.cos(Math.atan((this.control_ball.y - this.control_Y)/(this.control_ball.x - this.control_X))) * this.myCirArr[j].stance;
                //}
                //NPC球球移动  当NPC和世界地图以相同的速度、方向运动时，看起来只有我的小球在运动
                for (i = 0; i < this.bootCirArr.length; i++) {
                    cir = this.bootCirArr[i];
                    cir.x -= Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.mySporeArr.length; i++) {
                    spore = this.mySporeArr[i];
                    spore.x -= Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                //浮游物移动
                for (i = 0; i < this.bootAlgea.length; i++) {
                    algea = this.bootAlgea[i];
                    algea.x = algea.algeaX = algea.x - Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                //球刺移动
                for (i = 0; i < this.bootThorn.length; i++) {
                    thorn = this.bootThorn[i];
                    thorn.x -= Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
            }
            if (this.returnResult("top", this.myCirArr)) {
                for (i = 0; i < this.myCirArr.length; i++) {
                    if (this.mapTopFlag[i] == false) {
                        if (this.myCirArr[i] == myCir)
                            this.myCirArr[i].y += Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * (stance);
                        else
                            this.myCirArr[i].y += Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[i].stance;
                    }
                    else { }
                }
            }
            else {
                //世界地图移动，除最大球之外，小球相对于摄像机运动
                this.gameBackGround.y -= Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                //
                for (j = 0; j < this.myCirArr.length; j++) {
                    if (this.myCirArr[j] != myCir) {
                        this.myCirArr[j].y += Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[j].stance;
                    }
                }
                for (i = 0; i < this.bootCirArr.length; i++) {
                    cir = this.bootCirArr[i];
                    cir.y -= Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.mySporeArr.length; i++) {
                    spore = this.mySporeArr[i];
                    spore.y -= Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootAlgea.length; i++) {
                    algea = this.bootAlgea[i];
                    algea.y = algea.algeaY = algea.y - Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootThorn.length; i++) {
                    thorn = this.bootThorn[i];
                    thorn.y -= Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
            }
        }
        if (this.X > this.control_X && this.Y > this.control_Y) {
            if (this.returnResult("right", this.myCirArr)) {
                //我方球球不动  触碰的那个小球不动
                //this.gameBackGround.x = - (this.gameBackGround.width - GameManager.stage.stageWidth /2 - myCir.radius);
                //其他的小球继续运动，并且是小球运动，而不是世界地图运动
                //我方最大球球移动  地图移动
                //检测出已碰到边界的小球，不予操作（不动），其他小球则运动（世界地图停止运动，小球运动，最大球根据stance，小球根据自己的stance）
                for (i = 0; i < this.myCirArr.length; i++) {
                    if (this.mapRightFlag[i] == false) {
                        if (this.myCirArr[i] == myCir)
                            this.myCirArr[i].x += Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * (stance);
                        else
                            this.myCirArr[i].x += Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[i].stance;
                    }
                    else { }
                }
            }
            else {
                //我方所有小球移动 
                this.gameBackGround.x -= Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                //除最大球之外，小球相对于摄像机也在移动
                for (j = 0; j < this.myCirArr.length; j++) {
                    if (this.myCirArr[j] != myCir) {
                        this.myCirArr[j].x += Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[j].stance;
                    }
                }
                //NPC球球移动  当NPC和世界地图以相同的速度、方向运动时，看起来只有我的小球在运动
                for (i = 0; i < this.bootCirArr.length; i++) {
                    cir = this.bootCirArr[i];
                    cir.x -= Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.mySporeArr.length; i++) {
                    spore = this.mySporeArr[i];
                    spore.x -= Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                //浮游物移动
                for (i = 0; i < this.bootAlgea.length; i++) {
                    algea = this.bootAlgea[i];
                    algea.x = algea.algeaX = algea.x - Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootThorn.length; i++) {
                    thorn = this.bootThorn[i];
                    thorn.x -= Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
            }
            if (this.returnResult("bottom", this.myCirArr)) {
                for (i = 0; i < this.myCirArr.length; i++) {
                    if (this.mapBottomFlag[i] == false) {
                        if (this.myCirArr[i] == myCir)
                            this.myCirArr[i].y += Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * (stance);
                        else
                            this.myCirArr[i].y += Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[i].stance;
                    }
                    else { }
                }
            }
            else {
                this.gameBackGround.y -= Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                //
                for (j = 0; j < this.myCirArr.length; j++) {
                    if (this.myCirArr[j] != myCir) {
                        this.myCirArr[j].y += Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[j].stance;
                    }
                }
                for (i = 0; i < this.mySporeArr.length; i++) {
                    spore = this.mySporeArr[i];
                    spore.y -= Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootCirArr.length; i++) {
                    cir = this.bootCirArr[i];
                    cir.y -= Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootAlgea.length; i++) {
                    algea = this.bootAlgea[i];
                    algea.y = algea.algeaY = algea.y - Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootThorn.length; i++) {
                    thorn = this.bootThorn[i];
                    thorn.y -= Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
            }
        }
        if (this.X < this.control_X && this.Y < this.control_Y) {
            if (this.returnResult("left", this.myCirArr)) {
                for (i = 0; i < this.myCirArr.length; i++) {
                    if (this.mapLeftFlag[i] == false) {
                        if (this.myCirArr[i] == myCir)
                            this.myCirArr[i].x -= Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * (stance);
                        else
                            this.myCirArr[i].x -= Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[i].stance;
                    }
                    else { }
                }
            }
            else {
                this.gameBackGround.x += Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                for (j = 0; j < this.myCirArr.length; j++) {
                    if (this.myCirArr[j] != myCir) {
                        this.myCirArr[j].x -= Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[j].stance;
                    }
                }
                for (i = 0; i < this.mySporeArr.length; i++) {
                    spore = this.mySporeArr[i];
                    spore.x += Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootCirArr.length; i++) {
                    cir = this.bootCirArr[i];
                    cir.x += Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootAlgea.length; i++) {
                    algea = this.bootAlgea[i];
                    algea.x = algea.algeaX = algea.x + Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootThorn.length; i++) {
                    thorn = this.bootThorn[i];
                    thorn.x += Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
            }
            if (this.returnResult("top", this.myCirArr)) {
                for (i = 0; i < this.myCirArr.length; i++) {
                    if (this.mapTopFlag[i] == false) {
                        if (this.myCirArr[i] == myCir)
                            this.myCirArr[i].y -= Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * (stance);
                        else
                            this.myCirArr[i].y -= Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[i].stance;
                    }
                    else { }
                }
            }
            else {
                this.gameBackGround.y += Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                for (j = 0; j < this.myCirArr.length; j++) {
                    if (this.myCirArr[j] != myCir) {
                        this.myCirArr[j].y -= Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[j].stance;
                    }
                }
                for (i = 0; i < this.mySporeArr.length; i++) {
                    spore = this.mySporeArr[i];
                    spore.y += Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootCirArr.length; i++) {
                    cir = this.bootCirArr[i];
                    cir.y += Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootAlgea.length; i++) {
                    algea = this.bootAlgea[i];
                    algea.y = algea.algeaY = algea.y + Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootThorn.length; i++) {
                    thorn = this.bootThorn[i];
                    thorn.y += Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
            }
        }
        if (this.X < this.control_X && this.Y > this.control_Y) {
            if (this.returnResult("left", this.myCirArr)) {
                for (i = 0; i < this.myCirArr.length; i++) {
                    if (this.mapLeftFlag[i] == false) {
                        if (this.myCirArr[i] == myCir)
                            this.myCirArr[i].x -= Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * (stance);
                        else
                            this.myCirArr[i].x -= Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[i].stance;
                    }
                    else { }
                }
            }
            else {
                this.gameBackGround.x += Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                for (j = 0; j < this.myCirArr.length; j++) {
                    if (this.myCirArr[j] != myCir) {
                        this.myCirArr[j].x -= Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[j].stance;
                    }
                }
                for (i = 0; i < this.mySporeArr.length; i++) {
                    spore = this.mySporeArr[i];
                    spore.x += Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootCirArr.length; i++) {
                    cir = this.bootCirArr[i];
                    cir.x += Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootAlgea.length; i++) {
                    algea = this.bootAlgea[i];
                    algea.x = algea.algeaX = algea.x + Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootThorn.length; i++) {
                    thorn = this.bootThorn[i];
                    thorn.x += Math.cos(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
            }
            //this.gameBackGround.x = (GameManager.stage.stageWidth/2 - myCir.radius);
            if (this.returnResult("bottom", this.myCirArr)) {
                for (i = 0; i < this.myCirArr.length; i++) {
                    if (this.mapBottomFlag[i] == false) {
                        if (this.myCirArr[i] == myCir)
                            this.myCirArr[i].y -= Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * (stance);
                        else
                            this.myCirArr[i].y -= Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[i].stance;
                    }
                    else { }
                }
            }
            else {
                this.gameBackGround.y += Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                for (j = 0; j < this.myCirArr.length; j++) {
                    if (this.myCirArr[j] != myCir) {
                        this.myCirArr[j].y -= Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * this.myCirArr[j].stance;
                    }
                }
                for (i = 0; i < this.mySporeArr.length; i++) {
                    spore = this.mySporeArr[i];
                    spore.y += Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootCirArr.length; i++) {
                    cir = this.bootCirArr[i];
                    cir.y += Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootAlgea.length; i++) {
                    algea = this.bootAlgea[i];
                    algea.y = algea.algeaY = algea.y + Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
                for (i = 0; i < this.bootThorn.length; i++) {
                    thorn = this.bootThorn[i];
                    thorn.y += Math.sin(Math.atan((this.control_ball.y - this.control_Y) / (this.control_ball.x - this.control_X))) * stance;
                }
            }
        }
    };
    /**
     * 世界地图边缘碰撞检测
     *
     */
    GameControl.prototype.mapHitTest = function (circle) {
        var i;
        for (i = 0; i < circle.length; i++) {
            if (this.gameBackGround.x <= -(this.gameBackGround.width - (circle[i].x + circle[i].radius)))
                this.mapRightFlag[i] = true;
            else
                this.mapRightFlag[i] = false;
            if (this.gameBackGround.y >= (circle[i].y - circle[i].radius))
                this.mapTopFlag[i] = true;
            else
                this.mapTopFlag[i] = false;
            if (this.gameBackGround.x >= (circle[i].x - circle[i].radius))
                this.mapLeftFlag[i] = true;
            else
                this.mapLeftFlag[i] = false;
            if (this.gameBackGround.y <= -(this.gameBackGround.height - (circle[i].y + circle[i].radius)))
                this.mapBottomFlag[i] = true;
            else
                this.mapBottomFlag[i] = false;
        }
    };
    GameControl.prototype.returnResult = function (dir, circle) {
        var i;
        if (dir == "right") {
            for (i = 0; i < circle.length; i++) {
                if (this.mapRightFlag[i] == true) {
                    return true;
                }
            }
        }
        if (dir == "top") {
            for (i = 0; i < circle.length; i++) {
                if (this.mapTopFlag[i] == true) {
                    return true;
                }
            }
        }
        if (dir == "left") {
            for (i = 0; i < circle.length; i++) {
                if (this.mapLeftFlag[i] == true) {
                    return true;
                }
            }
        }
        if (dir == "bottom") {
            for (i = 0; i < circle.length; i++) {
                if (this.mapBottomFlag[i] == true) {
                    return true;
                }
            }
        }
    };
    /**
     * 控制盘定位
     */
    GameControl.prototype.onTouch = function (event) {
        //console.log("touch")
        if (this.controlFlag == false) {
            //重新计算坐标，将event.localX换成this.offsetLocalX；
            this.offsetLocalX = event.localX + ScaleMap.tempNumX;
            this.offsetLocalY = event.localY + ScaleMap.tempNumY;
            this.control_X = this.offsetLocalX;
            this.control_Y = this.offsetLocalY;
            this.control_bg.x = this.control_X;
            this.control_bg.y = this.control_Y;
            this.control_ball.x = this.control_X;
            this.control_ball.y = this.control_Y;
            this.addChild(this.control_bg);
            this.addChild(this.control_ball);
            this.controlFlag = true;
        }
        //console.log("test click is in move?")
        //console.log("move not in con_bg");
        //触碰位置在控制盘内
        if (event.target == this.control_bg) {
            //console.log("控制盘内" + event.localX);
            LayerManager.game.addEventListener(egret.Event.ENTER_FRAME, this.move, this);
            this.X = event.localX + this.control_X;
            this.Y = event.localY + this.control_Y;
            //console.log(event.localX + 120 ,event.localY + 360);
            this.control_ball.x = event.localX + this.control_X;
            this.control_ball.y = event.localY + this.control_Y;
        }
        else {
            LayerManager.game.addEventListener(egret.Event.ENTER_FRAME, this.move, this);
            this.offsetLocalX = event.localX + ScaleMap.tempNumX;
            this.offsetLocalY = event.localY + ScaleMap.tempNumY;
            //console.log("控制盘外 event.localX:" + event.localX + "event.localY: " +　this.offsetLocalX);
            this.X = this.offsetLocalX;
            this.Y = this.offsetLocalY;
            //console.log(event.localX + 120 ,event.localY + 360);
            var disX = this.control_X - (this.offsetLocalX);
            var disY = this.control_Y - (this.offsetLocalY);
            var distance = Math.sqrt((disX * disX) + (disY * disY));
            if (this.offsetLocalX > this.control_X && this.offsetLocalY < this.control_Y) {
                this.control_ball.y = this.control_Y - (this.conBgSize / distance) * (this.control_Y - this.offsetLocalY);
                this.control_ball.x = this.control_X + (this.conBgSize / distance) * (this.offsetLocalX - this.control_X);
            }
            if (this.offsetLocalX > this.control_X && this.offsetLocalY > this.control_Y) {
                this.control_ball.y = this.control_Y + (this.conBgSize / distance) * (this.offsetLocalY - this.control_Y);
                this.control_ball.x = this.control_X + (this.conBgSize / distance) * (this.offsetLocalX - this.control_X);
            }
            if (this.offsetLocalX < this.control_X && this.offsetLocalY < this.control_Y) {
                this.control_ball.y = this.control_Y - (this.conBgSize / distance) * (this.control_Y - this.offsetLocalY);
                this.control_ball.x = this.control_X - (this.conBgSize / distance) * (this.control_X - this.offsetLocalX);
            }
            if (this.offsetLocalX < this.control_X && this.offsetLocalY > this.control_Y) {
                this.control_ball.y = this.control_Y + (this.conBgSize / distance) * (this.offsetLocalY - this.control_Y);
                this.control_ball.x = this.control_X - (this.conBgSize / distance) * (this.control_X - this.offsetLocalX);
            }
        }
    };
    /**
     * 分裂入口
     *
     */
    GameControl.prototype.onSplit = function (event) {
        if (event.target == this.splitArea) {
            //console.log("dianji")
            var cirArr = []; //分裂后的球球
            //var tempCir : Circle[];
            var canSplitCir = []; //需要分裂的球球
            var cantSplitCir = []; //不需要分裂的球球
            var coor_bg;
            var coor_ball;
            var myCir;
            var i;
            var k = 0;
            var l = 0;
            //关闭定时器绘制，以免冲突
            //this.Timer.stop();
            coor_bg = new egret.Point(this.control_bg.x, this.control_bg.y);
            coor_ball = new egret.Point(this.control_ball.x, this.control_ball.y);
            //关闭我方球球碰撞检测
            this.splitHitTest = false;
            this.spliteHitTimer.start();
            //console.log(LayerManager.game.myCirArr.length);
            for (i = 0; i < LayerManager.game.myCirArr.length; i++) {
                if (LayerManager.game.myCirArr[i].weight >= (27000)) {
                    canSplitCir.push(LayerManager.game.myCirArr[i]);
                }
            }
            //console.log(LayerManager.game.myCirArr.length);
            var tempNum = LayerManager.game.myCirArr.length;
            var j = 0;
            for (i = 0; i < tempNum; i++) {
                if (LayerManager.game.myCirArr[j].weight >= (27000)) {
                    myCir = LayerManager.game.myCirArr[j];
                    LayerManager.game.removeChild(myCir);
                    LayerManager.game.myCirArr.splice(LayerManager.game.myCirArr.indexOf(myCir), 1);
                    Circle.reclaim(myCir, myCir.cirName);
                }
                else {
                    j += 1;
                }
            }
            //console.log("此时圆的个数应该为0" + LayerManager.game.myCirArr.length);
            if (canSplitCir.length >= 1) {
                cirArr = Split.splitAction(canSplitCir, coor_bg, coor_ball, this, LayerManager.game.gameStageWidth, LayerManager.game.gameStageHeight, LayerManager.game.gameBackGround, LayerManager.game.bootCirArr, LayerManager.game.bootAlgea);
                for (i = 0; i < cirArr.length; i++) {
                    var tempCir;
                    tempCir = cirArr[i];
                    LayerManager.game.myCirArr.push(tempCir);
                }
                while (cirArr.length > 0) {
                    cirArr.splice(cirArr.indexOf(cirArr[0]), 1);
                }
                //console.log(this.myCirArr.length);
                while (canSplitCir.length > 0) {
                    canSplitCir.splice(canSplitCir.indexOf(canSplitCir[0]), 1);
                }
            }
        }
    };
    /**
     * 孢子入口
     *
     */
    GameControl.prototype.onSpore = function (event) {
        if (event.target == this.spornArea) {
            //console.log("dianji")
            var sporeArr = []; //吐出的孢子
            //var tempCir : Circle[];
            var canSporeCir = []; //可以吐孢子的球球
            var cantSplitCir = []; //不可以吐孢子的球球
            var coor_bg;
            var coor_ball;
            var myCir;
            var i;
            var k = 0;
            var l = 0;
            coor_bg = new egret.Point(this.control_bg.x, this.control_bg.y);
            coor_ball = new egret.Point(this.control_ball.x, this.control_ball.y);
            //关闭我方球球碰撞检测
            this.spornHitTest = false;
            this.spornHitTimer.start();
            for (i = 0; i < LayerManager.game.myCirArr.length; i++) {
                if (LayerManager.game.myCirArr[i].weight >= (20 ^ 3)) {
                    canSporeCir.push(LayerManager.game.myCirArr[i]);
                }
            }
            var tempNum = LayerManager.game.myCirArr.length;
            var j = 0;
            for (i = 0; i < tempNum; i++) {
                if (LayerManager.game.myCirArr[i].weight >= (20 ^ 3) && LayerManager.game.myCirArr[i].weight < (50 ^ 3)) {
                    LayerManager.game.myCirArr[i].weight -= 90;
                }
                if (LayerManager.game.myCirArr[i].weight >= (50 ^ 3)) {
                    LayerManager.game.myCirArr[i].weight -= 90;
                }
            }
            if (canSporeCir.length >= 1) {
                sporeArr = Split.sporeAction(canSporeCir, coor_bg, coor_ball, this, LayerManager.game.gameStageWidth, LayerManager.game.gameStageHeight, LayerManager.game.gameBackGround, LayerManager.game.bootCirArr, LayerManager.game.bootAlgea);
                for (i = 0; i < sporeArr.length; i++) {
                    var tempSpore;
                    tempSpore = sporeArr[i];
                    LayerManager.game.mySpornArr.push(tempSpore);
                }
                while (sporeArr.length > 0) {
                    sporeArr.splice(sporeArr.indexOf(sporeArr[0]), 1);
                }
                //console.log(this.myCirArr.length);
                while (canSporeCir.length > 0) {
                    canSporeCir.splice(canSporeCir.indexOf(canSporeCir[0]), 1);
                }
            }
        }
    };
    /**
     * 控制点还原
     *
     */
    GameControl.prototype.touchEnd = function (event) {
        //如果单击的话，会触发TOUCH_END,不会触发TOUCH_MOVE，所以这里需要检测有无控制板再操作
        if (this.control_ball.parent != null && this.control_bg.parent != null) {
            //console.log("1111");
            this.removeChild(this.control_bg);
            this.removeChild(this.control_ball);
            this.controlFlag = false;
        }
        else {
            //如果单机，则停止小球移动
            if (event.target != this.splitArea)
                //console.log(this.control_ball.x,this.control_X,this.control_ball.y,this.control_Y);
                this.removeEventListener(egret.Event.ENTER_FRAME, this.move, this);
        }
        //这里不再需要判断鼠标的位置是否在控制盘内了，小球会一直运动，无需取消侦听，在下一次触碰后重新定位、显示控制盘即可
        //隐藏控制盘，继续侦听
    };
    GameControl.prototype.removeControl = function () {
        if (this.control_bg.parent != null)
            this.removeChild(this.control_bg);
        if (this.control_ball.parent != null)
            this.removeChild(this.control_ball);
        this.removeChild(this.splitArea);
        this.removeChild(this.spornArea);
        this.removeChild(this.rankingArea);
        this.rankingArr = [];
        this.spliteHitTimer.stop();
        this.removeEventListener(egret.TimerEvent.TIMER_COMPLETE, this.changeSplitStatus, this);
        this.spornHitTimer.stop();
        this.removeEventListener(egret.TimerEvent.TIMER_COMPLETE, this.changeSpornStatus, this);
        this.gameTimer.stop();
        this.removeEventListener(egret.TimerEvent.TIMER, this.onRefresh, this);
        this.removeEventListener(egret.TimerEvent.TIMER_COMPLETE, this.gameover, this);
    };
    return GameControl;
}(egret.DisplayObjectContainer));
__reflect(GameControl.prototype, "GameControl");
/**
 *
 * @auther   wangnan
 *
 * 球球作战游戏面板
 *
 *
 */
var GamePanel = (function (_super) {
    __extends(GamePanel, _super);
    function GamePanel() {
        var _this = _super.call(this) || this;
        //我方球球对象
        //private myCirclr : Circle;
        //我方球球半径
        _this.myCirR = 30;
        //我方球球重量
        _this.myWeight = 8000;
        //NPC数量
        _this.bootCirNum = 9;
        //NPC数组
        _this.bootCirArr = [];
        //世界地图边界flag
        _this.dirX = false;
        _this.dirY = false;
        //我方球球上一次位移记录
        _this.lastX = [];
        _this.lastY = [];
        //浮游物数组
        _this.bootAlgea = [];
        //浮游物数量
        _this.bootAlgeaNum = 200;
        //球刺数组
        _this.bootThorn = [];
        //球刺数量
        _this.bootThornNum = 10;
        //浮游物种类名字
        _this.algeaKindName = ["circle", "rect"];
        //世界地图缩放标准
        _this.scanlBase = 0.1;
        //上一次吃到的浮游物
        _this.lastEatAlgea = 50;
        //是否开启滤镜
        _this.isFilter = [];
        //控制盘大小
        _this.conBgSize = 50;
        //NPC半径大小
        _this.circleR = 15;
        _this.circleWeight = 3375;
        //我方球球数组
        _this.myCirArr = [];
        //球球孢子数组
        _this.mySpornArr = [];
        //半径缓存
        _this.cacheRadius = 0;
        _this.mackUp = 0;
        _this.sortingArr = [];
        //计数我方球球吞噬数量
        _this.myCirSwallowed = 0;
        _this.transX = 400;
        _this.transY = 240;
        _this.init();
        return _this;
    }
    GamePanel.prototype.init = function () {
        /*方案一：世界地图用一个黑色矩形
        this.touchEnabled = true;
        this.gameBackGround = new egret.Shape();
        this.gameBackGround.graphics.beginFill(0x000000,0.8);
        this.gameBackGround.graphics.drawRect(0,0,2000,2000);
        this.gameBackGround.graphics.endFill();
        this.gameBackGround.x = - (this.gameBackGround.width - GameManager.stage.stageWidth) /2;
        this.gameBackGround.y = - (this.gameBackGround.height - GameManager.stage.stageHeight) /2;
        this.addChild(this.gameBackGround);
        */
        /**
         * 方案二：世界地图用小图平铺
         */
        //this.gameBackGround = new egret.Bitmap(RES.getRes("bg_jpeg"));
        //this.gameBackGround.fillMode = egret.BitmapFillMode.REPEAT;
        //this.gameBackGround.width = 2000;
        //this.gameBackGround.height = 2540;
        //方案三：世界地图用一张大图
        this.gameBackGround = new egret.Bitmap(RES.getRes("timg_jpg"));
        this.touchEnabled = true;
        this.gameBackGround.x = -(this.gameBackGround.width - GameManager.stage.stageWidth) / 2;
        this.gameBackGround.y = -(this.gameBackGround.height - GameManager.stage.stageHeight) / 2;
        // this.gameBackGround.$setX(0);
        // this.gameBackGround.$setY(0);
        // this.gameBackGround.$setAnchorOffsetX(2136);
        // this.gameBackGround.$setAnchorOffsetY(100);
        this.addChild(this.gameBackGround);
        this.gameStageWidth = this.width;
        this.gameStageHeight = this.height;
        /**
         * 我方球球初始化
         */
        this.myCirArr.push(Circle.produce(this.myWeight, "myCirclr", 16776960, LayerManager.welcome.myCirName));
        if (this.myCirArr.length = 1) {
            this.myCirArr[0].x = GameManager.stage.stageWidth / 2;
            this.myCirArr[0].y = GameManager.stage.stageHeight / 2;
            this.addChild(this.myCirArr[0]);
        }
        else {
        }
        //console.log(GameManager.stage.stageWidth,GameManager.stage.width);
        /**
         * 创建NPC
         */
        this.creatCircle();
        /**
         * 创建浮游物
         */
        this.creatAlgea();
        /**
         * 创建球刺
         */
        this.creatThorn();
        /**
         * 重置我方球球位置
         */
        this.addChildAt(this.myCirArr[0], this.numChildren - 1);
        /**
         * 定时重绘
         *
         */
        this.Timer = new egret.Timer(10);
        this.Timer.addEventListener(egret.TimerEvent.TIMER, this.reGraMyCir, this);
        this.Timer.start();
        this.Timer2 = new egret.Timer(1000);
        this.Timer2.addEventListener(egret.TimerEvent.TIMER, this.reGraBootCir, this);
        this.Timer2.start();
        /**
         * 画面更新
         *
         */
        this.addEventListener(egret.Event.ENTER_FRAME, this.gameViewUpdata, this);
        /**
         * 外发光初始化
         *
         */
        // var i :　number ;
        // for( i = 0 ; i < this.myCirArr.length; i++){
        //     this.isFilter[i] = true;
        // }
        //将我方球球
    };
    /**
     * 外发光滤镜
     */
    GamePanel.prototype.applyGlowFilter = function (disp) {
        var color = 0x33CCFF;
        var alpha = 0.8;
        var blurX = 35;
        var blurY = 35;
        var strength = 2;
        var quality = 3 /* HIGH */;
        var inner = false;
        var knockout = false;
        var glowFilter = new egret.GlowFilter(color, alpha, blurX, blurY, strength, quality, inner, knockout);
        disp.filters = [glowFilter];
    };
    /**
     * 取消外发光
     *
     */
    GamePanel.prototype.cancleGlowFilter = function (disp) {
        var color = 0;
        var alpha = 0;
        var blurX = 0;
        var blurY = 0;
        var strength = 0;
        var quality = 3 /* HIGH */;
        var inner = false;
        var knockout = false;
        var glowFilter = new egret.GlowFilter(color, alpha, blurX, blurY, strength, quality, inner, knockout);
        disp.filters = [glowFilter];
    };
    /**
     * 创建NPC
     */
    GamePanel.prototype.creatCircle = function () {
        var nameArr = ["无情的杀手", "作业没做完", "明天又放假", "爱如潮水", "饥不择食", "欠揍的小学生", "冷酷的柯南", "送信的小朋友", "无理取闹的小明", "前端工程师", "微信不可信", "夜尽天明", "秋名山老司机", "周杰伦的双节棍", "可怜的备胎", "要出去打一架么", "甜甜的冰淇淋", "炎热的冬季", "杀马特杀马特", "发光的三极管", "红牛你最牛", "世上只有妈妈好", "吃不完兜着走", "我是一个小狮驼", "吸毒小能手", "信了你的鞋", "那就这样吧", "再爱都无需挣扎", "那就分手吧", "再闻一闻你的长发", "会哭的小鬼头", "肖生克的救赎", "放牛般的春天", "美丽人生", "愿主保佑你", "不是我的错"];
        while (this.bootCirArr.length < this.bootCirNum) {
            var py = Math.floor(Math.random() * (this.gameBackGround.height - this.circleR * 2)) + this.gameBackGround.y;
            var px = Math.floor(Math.random() * (this.gameBackGround.width - this.circleR * 2)) + this.gameBackGround.x;
            var circle = Circle.produce(this.circleWeight, "kind1", 16776960, nameArr[Math.floor(Math.random() * 36)]);
            circle.x = px;
            circle.y = py;
            this.bootCirArr.push(circle);
            this.addChild(circle);
            //给NPC数组进行运动方向初始化
            this.lastX[this.bootCirArr.length - 1] = 1;
            this.lastY[this.bootCirArr.length - 1] = 1;
        }
    };
    /**
     * 创建浮游生物
     */
    GamePanel.prototype.creatAlgea = function () {
        while (this.bootAlgea.length < this.bootAlgeaNum) {
            var py = Math.floor(Math.random() * (this.gameBackGround.height - 10)) + this.gameBackGround.y;
            var px = Math.floor(Math.random() * (this.gameBackGround.width - 10)) + this.gameBackGround.x;
            var algea = Algea.produce(4, this.algeaKindName[Math.floor(Math.random() * this.algeaKindName.length)]);
            algea.x = algea.algeaX = px;
            algea.y = algea.algeaY = py;
            this.addChild(algea);
            this.bootAlgea.push(algea);
        }
    };
    /**
     * 创建球刺
     */
    GamePanel.prototype.creatThorn = function () {
        while (this.bootThorn.length < this.bootThornNum) {
            var py = Math.floor(Math.random() * (this.gameBackGround.height - 10)) + this.gameBackGround.y;
            var px = Math.floor(Math.random() * (this.gameBackGround.width - 10)) + this.gameBackGround.x;
            var thornSize = Math.floor(Math.random() * 10 + 20);
            var thorn = Thorn.produce(thornSize, "circle");
            thorn.x = thorn.thornX = px;
            thorn.y = thorn.thornY = py;
            this.addChild(thorn);
            this.bootThorn.push(thorn);
        }
    };
    /**
     * NPC运动   碰撞检测
     */
    GamePanel.prototype.gameViewUpdata = function (event) {
        var x;
        var y;
        var i;
        var j;
        var cir;
        //小球运动
        for (i = 0; i < this.bootCirArr.length; i++) {
            cir = this.bootCirArr[i];
            var ranx = Math.random();
            var rany = Math.random();
            //较大的概率让小球保持原来的路径行走
            if (ranx >= 0.99)
                this.dirX = true;
            //如果超出边界，马上换个方向
            if ((cir.x - cir.radius) <= this.gameBackGround.x || cir.x >= (this.gameBackGround.x + this.gameBackGround.width - cir.radius))
                this.dirX = true;
            //小球行走
            if (this.dirX) {
                this.lastX[i] = -this.lastX[i];
            }
            //console.log(this.gameBackGround.x,cir.x,)
            if (rany >= 0.99)
                this.dirY = true;
            if (cir.y - cir.radius <= this.gameBackGround.y || cir.y >= (this.gameBackGround.y + this.gameBackGround.height - cir.radius))
                this.dirY = true;
            if (this.dirY) {
                this.lastY[i] = -this.lastY[i];
            }
            //这里决定了NPC的移动速度
            this.lastX[i] *= (1 - (cir.radius - this.circleR) / 10000);
            this.lastY[i] *= (1 - (cir.radius - this.circleR) / 10000);
            cir.x += this.lastX[i];
            cir.y += this.lastY[i];
            this.dirX = this.dirY = false;
            //碰撞检测
            this.gameHitTest();
            //NPC、浮游物重生
            this.reBirth();
            //刷新分数
            var allBulks = 0;
            for (j = 0; j < this.myCirArr.length; j++) {
                //console.log(j + " : " + this.myCirArr[j].bulk);
                allBulks += this.myCirArr[j].weight;
            }
            LayerManager.gameControl.myCirWeight = Math.floor(allBulks);
            LayerManager.gameControl.myCirBulk.text = "当前体积：" + Math.floor((allBulks)) + " kg";
            //小球分裂后会缩放地图
            //ScaleMap.scale(this.myCirArr,this.gameStageWidth, this.gameStageHeight,this.gameBackGround,this.bootCirArr,this.bootAlgea);
            ScaleMap.scale(this.myCirArr, this.gameStageWidth, this.gameStageHeight, this.gameBackGround, this.bootCirArr, this.bootAlgea);
            this.autoMove(LayerManager.game.myCirArr);
            //孢子边界检测
            this.sporeTest();
        }
    };
    /**
     * 碰撞检测
     */
    GamePanel.prototype.gameHitTest = function () {
        var j;
        var k;
        var i;
        var algea;
        var circle;
        var circle2;
        var myCir;
        var thorn;
        var spore;
        //将需要删除的浮游生物
        var delAlgea = [];
        var delCircle = [];
        var delMyCircle = [];
        var delThorn = [];
        var delSpore = [];
        //我方球球可以吃浮游生物
        for (j = 0; j < this.bootAlgea.length; j++) {
            algea = this.bootAlgea[j];
            for (k = 0; k < this.myCirArr.length; k++) {
                myCir = this.myCirArr[k];
                if (GameUtil.hitTest(myCir, algea)) {
                    //console.log("碰撞成功");
                    var disX = myCir.x - (algea.x + algea.distance);
                    var disY = myCir.y - (algea.y + algea.distance);
                    if (Math.sqrt((disX * disX) + (disY * disY)) <= myCir.radius) {
                        //将需要删除的浮藻压入删除数组
                        delAlgea.push(algea);
                        //我方球球体积增加
                        if (myCir.weight <= (50 ^ 3))
                            myCir.weight += (100); //浮游生物给求求增加0.1的半径大小
                        else
                            myCir.weight += 100; //减缓增长率
                    }
                }
            }
        }
        //电脑NPC可以吃浮游生物
        for (j = 0; j < this.bootCirArr.length; j++) {
            circle = this.bootCirArr[j];
            for (k = 0; k < this.bootAlgea.length; k++) {
                algea = this.bootAlgea[k];
                if (GameUtil.hitTest(circle, algea)) {
                    var disX = circle.x - (algea.x + algea.distance);
                    var disY = circle.y - (algea.y + algea.distance);
                    if (Math.sqrt((disX * disX) + (disY * disY)) <= circle.radius) {
                        //将需要删除的浮藻压入删除数组
                        delAlgea.push(algea);
                        //球球体积增加
                        circle.bulk += 0.4;
                        circle.weight += 100;
                    }
                }
            }
        }
        //电脑NPC可以吃孢子
        for (j = 0; j < this.bootCirArr.length; j++) {
            circle = this.bootCirArr[j];
            for (k = 0; k < this.mySpornArr.length; k++) {
                spore = this.mySpornArr[k];
                if (GameUtil.hitTest(circle, spore)) {
                    var disX = circle.x - (spore.x + spore.radius);
                    var disY = circle.y - (spore.y + spore.radius);
                    if (Math.sqrt((disX * disX) + (disY * disY)) <= spore.radius) {
                        //将需要删除的浮藻压入删除数组
                        delSpore.push(spore);
                        //球球体积增加
                        //spore.radius +=0.4;
                        circle.weight += 300;
                        circle.radius += 0.5;
                    }
                }
            }
        }
        //回收浮游生物
        while (delAlgea.length > 0) {
            algea = delAlgea.pop();
            if (algea.isLive == true) {
                this.removeChild(algea);
                this.bootAlgea.splice(this.bootAlgea.indexOf(algea), 1);
                algea.isLive = false;
                Algea.reclaim(algea, algea.algeaName);
            }
        }
        //我方球球和NPC之间可以大吃小
        for (j = 0; j < this.bootCirArr.length; j++) {
            circle = this.bootCirArr[j];
            for (k = 0; k < this.myCirArr.length; k++) {
                myCir = this.myCirArr[k];
                if (GameUtil.hitTest2(myCir, circle)) {
                    var disX = circle.x - myCir.x;
                    var disY = circle.y - myCir.y;
                    var bigCir_radius = myCir.radius > circle.radius ? myCir.radius : circle.radius;
                    //var bigCir : Circle = this.myCirclr.radius > circle.radius ? this.myCirclr : circle;
                    if (Math.sqrt((disX * disX) + (disY * disY)) <= bigCir_radius) {
                        if (myCir.radius <= circle.radius) {
                            //这里判断我方小球是否被吃完
                            if (delMyCircle.indexOf(myCir) == -1)
                                delMyCircle.push(myCir);
                            if (this.myCirArr.length == 1) {
                                this.gameOver();
                            }
                        }
                        else {
                            this.myCirSwallowed += 1;
                            //console.log(Math.sqrt((disX*disX) + (disY*disY)),this.myCirclr.radius);
                            //console.log(this.myCirclr.x,this.myCirclr.y,algea.x,algea.y);
                            //将需要删除的浮藻压入删除数组
                            delCircle.push(circle);
                            //我方球球体积增加
                            if (myCir.weight >= (50 ^ 3)) {
                                myCir.cacheWeight += ((circle.weight)); //30为NPC折换比例
                            }
                            else {
                                myCir.cacheWeight += (circle.weight); //30为NPC折换比例
                            }
                        }
                    }
                }
            }
        }
        //NPC之间可以互吃
        for (j = 0; j < this.bootCirArr.length; j++) {
            circle = this.bootCirArr[j];
            for (k = 0; k < this.bootCirArr.length; k++) {
                circle2 = this.bootCirArr[k];
                if (j != k) {
                    if (GameUtil.hitTest2(circle, circle2)) {
                        var disX = circle.x - circle2.x;
                        var disY = circle.y - circle2.y;
                        var bigCir = circle.radius > circle2.radius ? circle : circle2;
                        var minCir = circle.radius > circle2.radius ? circle2 : circle;
                        //var bigCir : Circle = this.myCirclr.radius > circle.radius ? this.myCirclr : circle;
                        if (Math.sqrt((disX * disX) + (disY * disY)) <= bigCir.radius) {
                            //我方球球体积增加
                            console.log("NPC碰撞");
                            bigCir.radius += (minCir.radius / 5); //30为NPC折换比例
                            bigCir.bulk += 1;
                            bigCir.weight += (minCir.radius / 5) ^ 3;
                            bigCir.swallowed += 1;
                            //将需要删除的浮藻压入删除数组
                            delCircle.push(minCir);
                        }
                    }
                }
            }
        }
        //我方球球之间可以合并 需要开启
        if (LayerManager.gameControl.splitHitTest == true) {
            for (j = 0; j < this.myCirArr.length; j++) {
                circle = this.myCirArr[j];
                for (k = 0; k < this.myCirArr.length; k++) {
                    circle2 = this.myCirArr[k];
                    if (j != k) {
                        if (GameUtil.hitTest2(circle, circle2)) {
                            var disX = circle.x - circle2.x;
                            var disY = circle.y - circle2.y;
                            var bigCir = circle.radius >= circle2.radius ? circle : circle2;
                            var minCir = circle2.radius <= circle.radius ? circle2 : circle;
                            //var bigCir : Circle = this.myCirclr.radius > circle.radius ? this.myCirclr : circle;
                            if (Math.sqrt((disX * disX) + (disY * disY)) <= bigCir.radius) {
                                //我方球球体积增加
                                //console.log(bigCir,minCir);
                                console.log("我方球球合并");
                                //分裂时半径对半，扎刺比例应该是4分，当最后一个刺球回归对半回加刚好增加扎刺的总体积
                                if (this.myCirArr.length == 2) {
                                    bigCir.cacheWeight += (minCir.weight);
                                }
                                else {
                                    bigCir.cacheWeight += (minCir.weight);
                                }
                                //将需要删除的浮藻压入删除数组
                                if (delMyCircle.indexOf(minCir) == -1)
                                    delMyCircle.push(minCir);
                            }
                            //立即回收被合并掉的我方球球   因为这里是我方俩个球球查询，有可能会互换位置
                            while (delMyCircle.length > 0) {
                                circle = delMyCircle.pop();
                                if (circle.isLive == true) {
                                    this.removeChild(circle);
                                    this.myCirArr.splice(this.myCirArr.indexOf(circle), 1);
                                    circle.isLive = false;
                                    if (circle.isLive == false) {
                                        circle.radius = this.circleR;
                                        //circle.skin.width = circle.height = circle.radius*2;
                                        //circle.skin.anchorOffsetX =  circle.radius;
                                        //circle.skin.anchorOffsetY =  circle.radius;
                                        Circle.reclaim(circle, circle.cirName);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        //我方球球扎刺
        for (j = 0; j < this.bootThorn.length; j++) {
            thorn = this.bootThorn[j];
            for (k = 0; k < this.myCirArr.length; k++) {
                myCir = this.myCirArr[k];
                if (GameUtil.hitTest2(myCir, thorn)) {
                    var disX = thorn.x - myCir.x;
                    var disY = thorn.y - myCir.y;
                    var bigCir_radius = myCir.radius > thorn.radius ? myCir.radius : thorn.radius;
                    if (Math.sqrt((disX * disX) + (disY * disY)) <= bigCir_radius) {
                        if (myCir.radius < thorn.radius) {
                        }
                        else {
                            //将需要删除的球刺压入删除数组
                            delThorn.push(thorn);
                            //我方球球体积减少
                            //这里改成 刺的体积加到球球里面，然后再进行分裂
                            // myCir.radius -= (myCir.radius/2);
                            // myCir.bulk -= myCir.radius/2;
                            this.splitWeight = (myCir.weight * 1 / 3 + thorn.weight);
                            myCir.cacheWeight = (myCir.weight * 2 / 3);
                            //关闭我方球球碰撞检测
                            LayerManager.gameControl.splitHitTest = false;
                            LayerManager.gameControl.spliteHitTimer.start();
                            //添加扎刺分裂
                            var tempThornArr = ThornSplit.splitAction(this.splitWeight, myCir, this);
                            //console.log(this.myCirArr.length);
                            for (i = 0; i < tempThornArr.length; i++) {
                                this.myCirArr.push(tempThornArr[i]);
                            }
                        }
                    }
                }
            }
        }
        //我方球球吃孢子
        if (LayerManager.gameControl.spornHitTest == true) {
            for (j = 0; j < this.mySpornArr.length; j++) {
                spore = this.mySpornArr[j];
                for (k = 0; k < this.myCirArr.length; k++) {
                    myCir = this.myCirArr[k];
                    if (GameUtil.hitTest2(myCir, spore)) {
                        var disX = spore.x - myCir.x;
                        var disY = spore.y - myCir.y;
                        var bigCir_radius = myCir.radius > spore.radius ? myCir.radius : spore.radius;
                        if (Math.sqrt((disX * disX) + (disY * disY)) <= bigCir_radius) {
                            if (myCir.radius <= 16) {
                            }
                            else {
                                //将需要删除的球刺压入删除数组
                                delSpore.push(spore);
                                //我方球球体积增加
                                if (myCir.weight >= (50 ^ 3)) {
                                    myCir.weight += 300;
                                }
                                else {
                                    myCir.weight += 300;
                                }
                            }
                        }
                    }
                }
            }
        }
        //回收被吃掉的NPC
        while (delCircle.length > 0) {
            circle = delCircle.pop();
            if (circle.isLive == true) {
                this.removeChild(circle);
                this.bootCirArr.splice(this.bootCirArr.indexOf(circle), 1);
                circle.isLive = false;
                if (circle.isLive == false) {
                    circle.radius = this.circleR;
                    Circle.reclaim(circle, circle.cirName);
                }
            }
        }
        //回收被合并掉的我方球球
        while (delMyCircle.length > 0) {
            circle = delMyCircle.pop();
            if (circle.isLive == true) {
                this.removeChild(circle);
                this.myCirArr.splice(this.myCirArr.indexOf(circle), 1);
                circle.isLive = false;
                if (circle.isLive == false) {
                    circle.radius = this.circleR;
                    //circle.skin.width = circle.height = circle.radius*2;
                    //circle.skin.anchorOffsetX =  circle.radius;
                    //circle.skin.anchorOffsetY =  circle.radius;
                    Circle.reclaim(circle, circle.cirName);
                }
            }
        }
        //回收被扎掉的球刺
        while (delThorn.length > 0) {
            thorn = delThorn.pop();
            if (thorn.isLive == true) {
                this.removeChild(thorn);
                this.bootThorn.splice(this.bootThorn.indexOf(thorn), 1);
                thorn.isLive = false;
                if (thorn.isLive == false) {
                    //thorn.radius = this.circleR;
                    Thorn.reclaim(thorn, thorn.thornName);
                }
            }
        }
        //回收被吃掉的孢子
        while (delSpore.length > 0) {
            spore = delSpore.pop();
            if (spore.isLive == true) {
                this.removeChild(spore);
                this.mySpornArr.splice(this.mySpornArr.indexOf(spore), 1);
                spore.isLive = false;
                if (spore.isLive == false) {
                    //thorn.radius = this.circleR;
                    Spore.reclaim(spore, spore.color);
                }
            }
        }
    };
    //回收掉的球球、浮游生物重生
    GamePanel.prototype.reBirth = function () {
        this.creatCircle();
        this.creatAlgea();
        this.creatThorn();
        //对数组重新排序
        //this.addChildAt(this.myCirclr,this.numChildren -1);
    };
    /**
     * 我方球球、NPC、浮游物重绘以及世界地图缩放
     *
     */
    GamePanel.prototype.reGraMyCir = function () {
        //console.log("当前球球数量：" + this.myCirArr.length);
        console.log("--------------------" + LayerManager.game.myCirArr.length + "个-----------------------");
        var i;
        var j;
        var circle;
        var algea;
        var myCir;
        var coreX;
        var coreY;
        var maxRadius = 0;
        //计算我方球球最大半径
        for (i = 0; i < this.myCirArr.length; i++) {
            if (this.myCirArr[i].radius > maxRadius)
                maxRadius = this.myCirArr[i].radius;
        }
        for (i = 0; i < this.myCirArr.length; i++) {
            if (this.myCirArr[i].cacheWeight >= 1 && this.myCirArr[i].cacheWeight < 30) {
                this.myCirArr[i].weight += 1;
                this.myCirArr[i].cacheWeight -= 1;
            }
            if (this.myCirArr[i].cacheWeight >= 30 && this.myCirArr[i].cacheWeight < 90) {
                this.myCirArr[i].weight += 30;
                this.myCirArr[i].cacheWeight -= 30;
            }
            if (this.myCirArr[i].cacheWeight >= 90 && this.myCirArr[i].cacheWeight < 500) {
                this.myCirArr[i].weight += 89;
                this.myCirArr[i].cacheWeight -= 89;
            }
            if (this.myCirArr[i].cacheWeight >= 500 && this.myCirArr[i].cacheWeight < 2000) {
                this.myCirArr[i].weight += 200;
                this.myCirArr[i].cacheWeight -= 200;
            }
            if (this.myCirArr[i].cacheWeight >= 2000 && this.myCirArr[i].cacheWeight < 20000) {
                this.myCirArr[i].weight += 500;
                this.myCirArr[i].cacheWeight -= 500;
            }
            if (this.myCirArr[i].cacheWeight >= 20000) {
                this.myCirArr[i].weight += 1000;
                this.myCirArr[i].cacheWeight -= 1000;
            }
        }
        for (j = 0; j < this.myCirArr.length; j++) {
            myCir = this.myCirArr[j];
            //我方球球与npc重绘
            if (myCir.radius < 50) {
                myCir.radius = Math.pow(myCir.weight, 1 / 3);
                if (myCir.skinName == "form2_png") {
                    myCir.removeChild(myCir.skin);
                    myCir.skin = new egret.Bitmap(RES.getRes("form1_png"));
                    myCir.skinName = "form1_png";
                    // myCir.addChild(myCir.skin);
                    myCir.addChildAt(myCir.skin, myCir.numChildren - 1);
                }
                myCir.skin.anchorOffsetX = myCir.radius;
                myCir.skin.anchorOffsetY = myCir.radius;
                myCir.skin.width = myCir.skin.height = myCir.radius * 2;
                //console.log("皮肤大小：" + myCir.skin.width/2);
                myCir.shape.graphics.clear();
                myCir.shape.graphics.beginFill(myCir.color);
                myCir.shape.graphics.drawCircle(0, 0, myCir.radius);
                myCir.shape.graphics.endFill();
                //console.log("球球半径："  + myCir.radius);
                if (myCir.weight > (25 ^ 3) && myCir.isFilter == false) {
                    myCir.isFilter = true;
                    this.applyGlowFilter(myCir);
                }
                if (myCir.radius < (25 ^ 3) && myCir.isFilter == true) {
                    myCir.isFilter = false;
                    //取消外发光这种用法是否正确待测试
                    this.cancleGlowFilter(myCir);
                }
            }
            else {
                //     //我方小球增长变缓，世界地图开始缩放，NPC与浮游生物也进行缩放并重新定位
                //     //我方球球体积增加
                //     myCir.shape.graphics.beginFill(myCir.color);
                //     myCir.shape.graphics.drawCircle(0,0, myCir.radius);
                //     myCir.shape.graphics.endFill();
                if (myCir.skinName == "form1_png") {
                    myCir.removeChild(myCir.skin);
                    myCir.skin = new egret.Bitmap(RES.getRes("form2_png"));
                    myCir.skinName = "form2_png";
                    //myCir.addChild(myCir.skin);
                    myCir.addChildAt(myCir.skin, myCir.numChildren - 1);
                }
                myCir.skin.anchorOffsetX = myCir.radius;
                myCir.skin.anchorOffsetY = myCir.radius;
                myCir.skin.width = myCir.skin.height = myCir.radius * 2;
                //console.log("皮肤大小：" + myCir.skin.width/2);
                myCir.shape.graphics.clear();
                myCir.shape.graphics.beginFill(myCir.color);
                myCir.shape.graphics.drawCircle(0, 0, myCir.radius);
                myCir.shape.graphics.endFill();
            }
        }
        this.lastEatAlgea = maxRadius;
    };
    GamePanel.prototype.reGraBootCir = function () {
        var circle;
        var tempCir;
        var i;
        var j;
        for (i = 0; i < this.bootCirArr.length; i++) {
            circle = this.bootCirArr[i];
            circle.shape.graphics.beginFill(circle.color);
            circle.shape.graphics.drawCircle(0, 0, circle.radius);
            circle.shape.graphics.endFill();
            //初始化排序数组
            this.sortingArr.push(this.bootCirArr[i]);
        }
        //重新排序
        for (i = 0; i < this.sortingArr.length - 1; i++) {
            for (j = 0; j < this.sortingArr.length - i - 1; j++) {
                if (this.sortingArr[j].radius < this.sortingArr[j + 1].radius) {
                    tempCir = this.sortingArr[j];
                    this.sortingArr[j] = this.sortingArr[j + 1];
                    this.sortingArr[j + 1] = tempCir;
                }
            }
        }
        //重新刷新排行榜
        LayerManager.gameControl.NO2.text = "2   " + this.sortingArr[0].name;
        LayerManager.gameControl.NO3.text = "3   " + this.sortingArr[1].name;
        LayerManager.gameControl.NO4.text = "4   " + this.sortingArr[2].name;
        LayerManager.gameControl.NO5.text = "5   " + this.sortingArr[3].name;
        LayerManager.gameControl.NO6.text = "6   " + this.sortingArr[4].name;
        LayerManager.gameControl.NO7.text = "7   " + this.sortingArr[5].name;
        LayerManager.gameControl.NO8.text = "8   " + this.sortingArr[6].name;
        LayerManager.gameControl.NO9.text = "9   " + this.sortingArr[7].name;
        LayerManager.gameControl.NO10.text = "10   " + this.sortingArr[8].name;
        //console.log(LayerManager.gameControl.NO2.text = "2   " + this.sortingArr[0].name;
        //清空排名数组
        this.sortingArr = [];
    };
    /**
     * 游戏结束
     */
    GamePanel.prototype.gameOver = function () {
        //console.log("游戏结束");
        //console.log(this);
        //回收屏幕上对象
        var i;
        if (this.parent != null) {
            var algea;
            var circle;
            var thorn;
            while (this.bootAlgea.length > 0) {
                algea = this.bootAlgea.pop();
                this.removeChild(algea);
                this.bootAlgea.splice(this.bootAlgea.indexOf(algea), 1);
                Algea.reclaim(algea, algea.algeaName);
            }
            while (this.bootCirArr.length > 0) {
                circle = this.bootCirArr.pop();
                if (circle.isLive == true) {
                    this.removeChild(circle);
                    this.bootCirArr.splice(this.bootCirArr.indexOf(circle), 1);
                    circle.isLive = false;
                    Circle.reclaim(circle, circle.cirName);
                }
            }
            while (this.myCirArr.length > 0) {
                circle = this.myCirArr.pop();
                if (circle.isLive == true) {
                    this.removeChild(circle);
                    this.myCirArr.splice(this.myCirArr.indexOf(circle), 1);
                    circle.isLive = false;
                    Circle.reclaim(circle, circle.cirName);
                }
            }
            while (this.bootThorn.length > 0) {
                thorn = this.bootThorn.pop();
                if (thorn.isLive == true) {
                    this.removeChild(thorn);
                    this.bootThorn.splice(this.bootThorn.indexOf(thorn), 1);
                    thorn.isLive = false;
                    Thorn.reclaim(thorn, thorn.thornName);
                }
            }
            this.cacheRadius = 0;
            this.sortingArr = [];
            //移除对象、侦听器
            // this.removeEventListener(egret.TouchEvent.TOUCH_MOVE,this.onTouch,this);
            // this.removeEventListener(egret.TouchEvent.TOUCH_END,this.touchEnd,this);
            //this.removeEventListener(egret.Event.ENTER_FRAME,this.move,this);
            this.Timer.stop();
            this.Timer.removeEventListener(egret.TimerEvent.TIMER, this.reGraMyCir, this);
            this.Timer2.stop();
            this.Timer2.removeEventListener(egret.TimerEvent.TIMER, this.reGraBootCir, this);
            this.removeEventListener(egret.Event.ENTER_FRAME, this.gameViewUpdata, this);
            //删除游戏控制盘和分裂按钮
            LayerManager.gameControl.removeControl();
            //添加游戏结束面板
            //LayerManager.gameLayer.removeChild(this);
            //var gameOver : GameOverPanel = new GameOverPanel;
            //LayerManager.gameLayer.addChild(gameOver);
            console.log("游戏结束");
        }
    };
    GamePanel.prototype.autoMove = function (circle) {
        var i;
        this.transX = -ScaleMap.tempNumX + 400;
        this.transY = -ScaleMap.tempNumY + 240;
        for (i = 0; i < circle.length; i++) {
            //console.log(circle[i].x,circle[i].y);
            if (circle[i].x > this.transX && circle[i].y < this.transY) {
                circle[i].x -= 0.04;
                circle[i].y += 0.04;
            }
            if (circle[i].x < this.transX && circle[i].y < this.transY) {
                circle[i].x += 0.04;
                circle[i].y += 0.04;
            }
            if (circle[i].x < this.transX && circle[i].y > this.transY) {
                circle[i].x += 0.04;
                circle[i].y -= 0.04;
            }
            if (circle[i].x > this.transX && circle[i].y > this.transY) {
                circle[i].x -= 0.04;
                circle[i].y -= 0.04;
            }
        }
    };
    GamePanel.prototype.sporeTest = function () {
        var i;
        var spore;
        var cir;
        for (i = 0; i < this.mySpornArr.length; i++) {
            spore = this.mySpornArr[i];
            if (spore.x + spore.radius >= LayerManager.game.gameBackGround.width + LayerManager.game.gameBackGround.x) {
                egret.Tween.removeTweens(spore);
                spore.x = LayerManager.game.gameBackGround.width + LayerManager.game.gameBackGround.x - spore.radius;
            }
            if (spore.y - spore.radius <= LayerManager.game.gameBackGround.y) {
                egret.Tween.removeTweens(spore);
                spore.y = LayerManager.game.gameBackGround.y + spore.radius;
            }
            if (spore.x - spore.radius <= LayerManager.game.gameBackGround.x) {
                egret.Tween.removeTweens(spore);
                spore.x = LayerManager.game.gameBackGround.x + spore.radius;
            }
            if (spore.y + spore.radius >= LayerManager.game.gameBackGround.height + LayerManager.game.gameBackGround.y) {
                egret.Tween.removeTweens(spore);
                spore.y = LayerManager.game.gameBackGround.height + LayerManager.game.gameBackGround.y - spore.radius;
            }
        }
        for (i = 0; i < this.myCirArr.length; i++) {
            cir = this.myCirArr[i];
            if (cir.x + cir.radius >= LayerManager.game.gameBackGround.width + LayerManager.game.gameBackGround.x) {
                egret.Tween.removeTweens(cir);
                cir.x = LayerManager.game.gameBackGround.width + LayerManager.game.gameBackGround.x - cir.radius;
            }
            if (cir.y - cir.radius <= LayerManager.game.gameBackGround.y) {
                egret.Tween.removeTweens(cir);
                cir.y = LayerManager.game.gameBackGround.y + cir.radius;
            }
            if (cir.x - cir.radius <= LayerManager.game.gameBackGround.x) {
                egret.Tween.removeTweens(cir);
                cir.x = LayerManager.game.gameBackGround.x + cir.radius;
            }
            if (cir.y + cir.radius >= LayerManager.game.gameBackGround.height + LayerManager.game.gameBackGround.y) {
                egret.Tween.removeTweens(cir);
                cir.y = LayerManager.game.gameBackGround.height + LayerManager.game.gameBackGround.y - cir.radius;
            }
        }
    };
    return GamePanel;
}(egret.DisplayObjectContainer));
__reflect(GamePanel.prototype, "GamePanel");
var GameUtil = (function () {
    function GameUtil() {
    }
    /**基于矩形的碰撞检测*/
    GameUtil.hitTest = function (obj1, obj2) {
        var rect1 = obj1.getBounds();
        var rect2 = obj2.getBounds();
        rect1.x = obj1.x - obj1.width / 2;
        rect1.y = obj1.y - obj1.height / 2;
        rect2.x = obj2.x;
        rect2.y = obj2.y;
        //console.log(obj1.x,obj1.y) 
        //console.log(rect1.width,rect1.height,rect2.width,rect2.height);
        //console.log(rect1.x,rect1.y,rect2.x,rect2.y);
        return rect1.intersects(rect2);
    };
    /**圆形碰撞检测 */
    GameUtil.hitTest2 = function (obj1, obj2) {
        var rect1 = obj1.getBounds();
        var rect2 = obj2.getBounds();
        rect1.x = obj1.x - obj1.width / 2;
        rect1.y = obj1.y - obj1.height / 2;
        rect2.x = obj2.x - obj2.width / 2;
        rect2.y = obj2.y - obj2.height / 2;
        //console.log(obj1.x,obj1.y) 
        //console.log(rect1.width,rect1.height,rect2.width,rect2.height);
        //console.log(rect1.x,rect1.y,rect2.x,rect2.y);
        return rect1.intersects(rect2);
    };
    return GameUtil;
}());
__reflect(GameUtil.prototype, "GameUtil");
// TypeScript file
/**
 *
 * 地图缩放，由球球之间的距离决定（减去俩圆半径），距离越远，缩放比例越大，但最大不能让世界地图在摄像机之内
 *
 * 缩放比例为： 在俩球之间距离的200px之内，世界地图可以缩放自己原本大小的一半，超过200px，不再缩放
 *
 * 这个方法最好在一开始时，俩球距离很小时，就连续使用，一直到最大，并在updataView中调用，一直侦听俩球的距离
 *
 * 因为根据我方最大的球球，世界地图也一直在缩放，这里以距离的缩放要以球球的体积缩放为参考
 *
 *
 *
 */
var ScaleMap = (function () {
    function ScaleMap() {
        // this.init();
    }
    ScaleMap.scale = function (circle, gameStageW, gameStageH, gameBG, bootCirArr, bootAlgea) {
        var cir = circle;
        var doubleZoomScale;
        var i;
        //var maxRadius : number = circle[0].radius;
        var maxCir = circle[0];
        //计算圆之间的距离
        if (circle.length > 1) {
            //console.log("更新中")
            //console.log(gameStageH,gameStageW);
            doubleZoomScale = this.getZoomScale(cir);
            //console.log(zoomScale);
            for (i = 0; i < circle.length; i++) {
                if (circle[i].radius >= maxCir.radius) {
                    maxCir = circle[i];
                }
            }
            if (maxCir.radius >= 50) {
                this.singleZommScale = -((maxCir.radius - 50) / 500);
            }
            else {
                this.singleZommScale = 0;
            }
            //以这个距离计算出缩放比例，立马执行缩放（改变世界地图的高宽度、位移）
            //console.log("缩放大小："+zoomScale);
            // console.log("球的数量：" + cir.length);
            this.zoomScale = doubleZoomScale + this.singleZommScale;
            this.runZoom(this.zoomScale, cir, gameStageW, gameStageH, gameBG, bootCirArr, bootAlgea);
        }
        if (circle.length == 1) {
            //将视角拉回我方球球，地图缩放还原
            //console.log(LayerManager.game.scaleX);
            if (circle[0].radius >= 50) {
                this.singleZommScale = -((circle[0].radius - 50) / 500);
                this.runZoom(1 + this.singleZommScale, cir, gameStageW, gameStageH, gameBG, bootCirArr, bootAlgea);
            }
            else {
                this.singleZommScale = 0;
                this.lastWidth = 2136;
                this.lastHeight = 1200;
                this.zoomScale = 1;
                LayerManager.game.$setScaleX(this.zoomScale);
                LayerManager.game.$setScaleY(this.zoomScale);
            }
        }
    };
    ScaleMap.getZoomScale = function (circle) {
        var zoomScale;
        var i;
        var maxCirX = circle[0].x;
        var maxCirY = circle[0].y;
        var minCirX = circle[0].x;
        var minCiry = circle[0].y;
        for (i = 0; i < circle.length; i++) {
            if (circle[i].x > maxCirX)
                maxCirX = circle[i].x;
            if (circle[i].x < minCirX)
                minCirX = circle[i].x;
            if (circle[i].y > maxCirY)
                maxCirY = circle[i].y;
            if (circle[i].y < minCiry)
                minCiry = circle[i].y;
        }
        //console.log("第一个球坐标：" +circle[0].x , circle[0].y);
        //console.log( "第二个球坐标："+circle[1].x , circle[1].y);
        var diffX = maxCirX - minCirX;
        var diffY = maxCirY - minCiry;
        var maxDiff = diffX > diffY ? diffX : diffY;
        //这里设定缩放比例最大为世界地图的0.5，基数为800像素
        if (maxDiff / 400 == 0)
            zoomScale = 1;
        if (maxDiff / 400 > 0 && maxDiff / 400 < 1)
            zoomScale = 1 - maxDiff / 1000;
        if (maxDiff / 400 >= 1)
            zoomScale = maxDiff / 800;
        //缩放范围是0.5 - 1
        //console.log(zoomScale);
        return zoomScale;
    };
    ScaleMap.runZoom = function (zoomScale, cir, gameStageW, gameStageH, gameBG, bootCirArr, bootAlgea) {
        //console.log("缩放中")
        LayerManager.game.$setScaleX(zoomScale);
        LayerManager.game.$setScaleY(zoomScale);
        //console.log(LayerManager.game.width, LayerManager.game.height,gameStageW,gameStageH);
        if (zoomScale < this.lastZoomScale) {
            LayerManager.game.x += Math.abs((this.lastWidth - this.lastWidth * zoomScale) / 16);
            LayerManager.game.y += Math.abs((this.lastHeight - this.lastHeight * zoomScale) / 16);
            this.tempNumX += Math.abs((this.lastWidth - this.lastWidth * zoomScale) / 16);
            this.tempNumY += Math.abs((this.lastHeight - this.lastHeight * zoomScale) / 16);
        }
        if (zoomScale > this.lastZoomScale) {
            LayerManager.game.x -= Math.abs((this.lastWidth - this.lastWidth * zoomScale) / 16);
            LayerManager.game.y -= Math.abs((this.lastHeight - this.lastHeight * zoomScale) / 16);
            this.tempNumY -= Math.abs((this.lastHeight - this.lastHeight * zoomScale) / 16);
            this.tempNumX -= Math.abs((this.lastWidth - this.lastWidth * zoomScale) / 16);
        }
        //console.log(Math.abs((this.lastWidth - gameStageW * zoomScale)/2),Math.abs((this.lastHeight - gameStageH *  zoomScale)/2));
        this.lastWidth = this.lastScaleW * zoomScale;
        this.lastHeight = this.lastHeight * zoomScale;
        this.lastZoomScale = zoomScale;
        //console.log(this.tempNumX,this.tempNumY);
    };
    return ScaleMap;
}());
ScaleMap.lastZoomScale = 1;
ScaleMap.lastWidth = 2136;
ScaleMap.lastHeight = 1200;
ScaleMap.lastScaleW = 0;
ScaleMap.lastScaleH = 0;
ScaleMap.testNum = 1;
ScaleMap.offsetX = 0;
ScaleMap.offsetY = 0;
ScaleMap.tempNumX = 0;
ScaleMap.tempNumY = 0;
ScaleMap.singleZommScale = 0;
__reflect(ScaleMap.prototype, "ScaleMap");
// TypeScript file
var Split = (function () {
    function Split() {
    }
    Split.splitAction = function (circle, coor_bg, coor_ball, tha, gameStageW, gameStageH, gameBG, bootCirArr, bootAlgea) {
        var i;
        var cir;
        var cirArr = [];
        var j = 0;
        // var distanceArr : number[] = [];
        // var disX : number = coor_ball.x - coor_bg.x;
        // var disY : number = coor_ball.y - coor_bg.y;
        // var hypotenuse : number = Math.sqrt(disX *disX + disY * disY);
        // var cos : number = Math.abs(disX) / hypotenuse;
        // //var radian : any= Math.acos(cos) * 360 / 2*Math.PI;
        // var radian  =  Math.floor(180/(Math.PI/Math.acos(cos)));
        //console.log(radian);
        //var radian2 : number = Math.atan(Math.abs(disX)/Math.abs(disY)) * 360 / 2*Math.PI;
        var lenthX = [];
        var lenthY = [];
        for (i = 0; i < circle.length; i++) {
            lenthX[i] = Math.cos(Math.atan((LayerManager.gameControl.control_ball.y - LayerManager.gameControl.control_Y) / (LayerManager.gameControl.control_ball.x - LayerManager.gameControl.control_X))) * circle[i].radius * 2.5;
            lenthY[i] = Math.sin(Math.atan((LayerManager.gameControl.control_ball.y - LayerManager.gameControl.control_Y) / (LayerManager.gameControl.control_ball.x - LayerManager.gameControl.control_X))) * circle[i].radius * 2.5;
        }
        // if(disX >= 0 && disY <= 0){
        // }
        // if(disX <= 0 && disY <= 0){
        //     radian = 180 - radian;
        // }
        // if(disX <= 0 && disY >= 0){
        //     radian = 180 + radian;
        // }
        // if(disX >= 0 && disY >= 0){
        //     radian = 360 - radian;
        // }
        //console.log(radian);
        for (i = 0; i < circle.length; i++) {
            console.log("可以分裂的球的XY：" + circle[i].x, circle[i].y);
            this.cirX[i] = circle[i].x;
            this.cirY[i] = circle[i].y;
            this.cirR[i] = circle[i].radius;
            this.weight[i] = circle[i].weight;
            console.log("可以分裂的球球" + i + "半径： " + circle[i].radius);
        }
        var r;
        for (i = 0; i < circle.length; i++) {
            cir = circle[i];
            r = this.cirR[i] / 2;
            console.log(r);
            //var cirX : number  = cir.x;
            //var cirY : number  = cir.y;
            for (j = 0; j < 2; j++) {
                //console.log(cir.cirName)
                var newCir = Circle.produce(this.weight[i] / 2, cir.cirName, cir.color, cir.name);
                //newCir.bulk = newCir.radius;
                newCir.x = this.cirX[i];
                newCir.y = this.cirY[i];
                console.log("X : " + newCir.x, "Y : " + newCir.y);
                if (cirArr.indexOf(newCir) == -1)
                    cirArr.push(newCir);
                LayerManager.game.addChild(newCir);
            }
        }
        // for( i = 0; i < circle.length; i++){
        //     cir = circle[i];
        //     console.log("可以分裂的球的坐标：" + circle[i].x + "," + circle[i].y );
        //     r= circle[i].radius;
        //     //console.log(cir.radius);
        //     //var cirX : number  = cir.x;
        //     //var cirY : number  = cir.y;
        //     for( j = 0; j < 2; j ++){
        //         //console.log(cir.cirName)
        //         var newCir : Circle = Circle.produce(r/2,cir.cirName,cir.color);
        //         newCir.bulk = newCir.radius;
        //         newCir.x = circle[i].x;
        //         newCir.y = circle[i].y;
        //         console.log("X : " + newCir.x , "Y : " + newCir.y)
        //         if(cirArr.indexOf(newCir) == -1)
        //             cirArr.push(newCir);
        //         LayerManager.game.addChild(newCir);
        //     }
        // }
        var flag = false;
        //var j : number ; 
        var newXorY;
        for (i = 0; i < cirArr.length; i++) {
            cir = cirArr[i];
            if (i % 2 == 1)
                j = i / 2 - 0.5;
            if (i % 2 == 0)
                j = i / 2;
            if (i % 2 == 0) {
                //正方向缓动
                //通过判断控制盘的坐标，来操作我的小球的运动方向
                if (LayerManager.gameControl.X > LayerManager.gameControl.control_X && LayerManager.gameControl.Y < LayerManager.gameControl.control_Y) {
                    egret.Tween.get(cir).to({ x: cir.x + lenthX[j], y: cir.y + lenthY[j] }, 600, egret.Ease.sineIn);
                }
                if (LayerManager.gameControl.X > LayerManager.gameControl.control_X && LayerManager.gameControl.Y > LayerManager.gameControl.control_Y) {
                    egret.Tween.get(cir).to({ x: cir.x + lenthX[j], y: cir.y + lenthY[j] }, 600, egret.Ease.sineIn);
                }
                if (LayerManager.gameControl.X < LayerManager.gameControl.control_X && LayerManager.gameControl.Y < LayerManager.gameControl.control_Y) {
                    egret.Tween.get(cir).to({ x: cir.x - lenthX[j], y: cir.y - lenthY[j] }, 600, egret.Ease.sineIn);
                }
                if (LayerManager.gameControl.X < LayerManager.gameControl.control_X && LayerManager.gameControl.Y > LayerManager.gameControl.control_Y) {
                    egret.Tween.get(cir).to({ x: cir.x - lenthX[j], y: cir.y - lenthY[j] }, 600, egret.Ease.sineIn);
                }
            }
        }
        //cirArr中所有的圆要返回给gamepanel的圆数组中
        console.log("返回的圆个数：" + cirArr.length);
        return cirArr;
    };
    //private static onScale (circle : Circle[] , gameStageW : number , gameStageH : number,gameBG : egret.Bitmap,bootCirArr : Circle[], bootAlgea : Algea[]){
    //    ScaleMap.scale(circle,  gameStageW , gameStageH,gameBG ,bootCirArr, bootAlgea )
    //}
    Split.sporeAction = function (circle, coor_bg, coor_ball, tha, gameStageW, gameStageH, gameBG, bootCirArr, bootAlgea) {
        //console.log("分裂一次");
        var i;
        var cir;
        //  需要返回的孢子
        var sporeArr = [];
        var distanceArr = [];
        var disX = coor_ball.x - coor_bg.x;
        var disY = coor_ball.y - coor_bg.y;
        var hypotenuse = Math.sqrt(disX * disX + disY * disY);
        var cos = Math.abs(disX) / hypotenuse;
        // console.log(cos);
        //var radian : any= Math.acos(cos) * 360 / 2*Math.PI;
        var radian = Math.floor(180 / (Math.PI / Math.acos(cos)));
        //console.log(radian);
        //var radian2 : number = Math.atan(Math.abs(disX)/Math.abs(disY)) * 360 / 2*Math.PI;
        //console.log(radian2);
        var lenthX = [];
        var lenthY = [];
        for (i = 0; i < circle.length; i++) {
            lenthX[i] = Math.cos(Math.atan((LayerManager.gameControl.control_ball.y - LayerManager.gameControl.control_Y) / (LayerManager.gameControl.control_ball.x - LayerManager.gameControl.control_X))) * circle[i].radius * 4;
            lenthY[i] = Math.sin(Math.atan((LayerManager.gameControl.control_ball.y - LayerManager.gameControl.control_Y) / (LayerManager.gameControl.control_ball.x - LayerManager.gameControl.control_X))) * circle[i].radius * 4;
        }
        var r;
        for (i = 0; i < circle.length; i++) {
            cir = circle[i];
            r = cir.radius;
            //console.log(cir.radius);
            //var cirX : number  = cir.x;
            //var cirY : number  = cir.y;
            //console.log(cir.cirName)
            console.log(cir.color);
            var newSpore = Spore.produce(9, cir.color);
            newSpore.x = cir.x;
            newSpore.y = cir.y;
            if (sporeArr.indexOf(newSpore) == -1)
                sporeArr.push(newSpore);
            LayerManager.game.addChildAt(newSpore, 1);
        }
        var flag = false;
        var j;
        var spore;
        var newX;
        var newY;
        for (i = 0; i < sporeArr.length; i++) {
            spore = sporeArr[i];
            if (LayerManager.gameControl.X >= LayerManager.gameControl.control_X && LayerManager.gameControl.Y <= LayerManager.gameControl.control_Y) {
                egret.Tween.get(spore).to({ x: spore.x + lenthX[i], y: spore.y + lenthY[i] }, 300, egret.Ease.sineIn);
            }
            if (LayerManager.gameControl.X > LayerManager.gameControl.control_X && LayerManager.gameControl.Y > LayerManager.gameControl.control_Y) {
                egret.Tween.get(spore).to({ x: spore.x + lenthX[i], y: spore.y + lenthY[i] }, 300, egret.Ease.sineIn);
            }
            if (LayerManager.gameControl.X < LayerManager.gameControl.control_X && LayerManager.gameControl.Y < LayerManager.gameControl.control_Y) {
                egret.Tween.get(spore).to({ x: spore.x - lenthX[i], y: spore.y - lenthY[i] }, 300, egret.Ease.sineIn);
            }
            if (LayerManager.gameControl.X < LayerManager.gameControl.control_X && LayerManager.gameControl.Y > LayerManager.gameControl.control_Y) {
                egret.Tween.get(spore).to({ x: spore.x - lenthX[i], y: spore.y - lenthY[i] }, 300, egret.Ease.sineIn);
            }
        }
        return sporeArr;
    };
    return Split;
}());
Split.cirX = [];
Split.cirY = [];
Split.cirR = [];
Split.weight = [];
__reflect(Split.prototype, "Split");
/**
 * 孢子精灵，可实例化为孢子
 *
 */
var Spore = (function (_super) {
    __extends(Spore, _super);
    function Spore(r, color) {
        var _this = _super.call(this) || this;
        //孢子生命
        _this.isLive = false;
        _this.init(r, color);
        return _this;
    }
    //孢子名字
    //public spornName : string;
    Spore.prototype.init = function (r, color) {
        this.color = color;
        this.radius = r;
        this.shape = new egret.Shape();
        this.shape.graphics.beginFill(this.color);
        this.shape.graphics.drawCircle(0, 0, this.radius);
        this.shape.graphics.endFill();
        this.isLive = true;
        this.addChild(this.shape);
    };
    Spore.produce = function (r, color) {
        if (Spore.cacheSpore[color.toString()] == null) { }
        Spore.cacheSpore[color.toString()] = [];
        var tempSporeArr = Spore.cacheSpore[color.toString()];
        if (tempSporeArr.length > 0) {
            var spore = tempSporeArr.pop();
            spore.isLive = true;
        }
        else
            var spore = new Spore(r, color);
        return spore;
    };
    Spore.reclaim = function (spore, color) {
        if (Spore.cacheSpore[color.toString()] == null) { }
        Spore.cacheSpore[color.toString()] = [];
        var tempSporeArr = Spore.cacheSpore[color.toString()];
        if (tempSporeArr.indexOf(spore) == -1)
            tempSporeArr.push(spore);
    };
    return Spore;
}(egret.Sprite));
Spore.cacheSpore = {};
__reflect(Spore.prototype, "Spore");
/**
 * 浮游物精灵，可实例化为浮游生物
 */
var Algea = (function (_super) {
    __extends(Algea, _super);
    function Algea(r, kindName) {
        var _this = _super.call(this) || this;
        //浮游物生命
        _this.isLive = false;
        //public bulk : number;
        //浮游物颜色列表
        _this.colorList = [13408665, 16777113, 6710937, 6710937, 16750848, 16776960, 39372, 13421721, 13382553, 10079232, 16737894, 16776960, 3381708, 13395456];
        _this.init(r, kindName);
        return _this;
    }
    //浮游物数据初始化
    Algea.prototype.init = function (r, kindName) {
        this.shape = new egret.Shape();
        this.distance = r;
        //this.bulk = 3.14 * this.radius * this.radius;
        this.algeaName = kindName;
        this.color = this.colorList[Math.floor(Math.random() * this.colorList.length)];
        this.shape.graphics.beginFill(this.color);
        if (kindName == "circle")
            this.shape.graphics.drawCircle(0, 0, r);
        else if (kindName == "rect")
            this.shape.graphics.drawRect(0, 0, 2 * r, 2 * r);
        this.shape.graphics.endFill();
        //this.shape.x = px;
        //this.shape.y = py;
        this.isLive = true;
        this.addChild(this.shape);
    };
    //浮游物生产
    Algea.produce = function (r, kindName) {
        if (Algea.cacheAlgea[kindName] == null)
            Algea.cacheAlgea[kindName] = [];
        var tempAlgeaArr = Algea.cacheAlgea[kindName];
        var algea;
        if (tempAlgeaArr.length > 0) {
            algea = tempAlgeaArr.pop();
            algea.isLive = true;
        }
        else
            algea = new Algea(r, kindName);
        return algea;
    };
    //浮游物回收
    Algea.reclaim = function (algea, kindName) {
        if (Algea.cacheAlgea[kindName] == null)
            Algea.cacheAlgea[kindName] = [];
        var tempAlgeaArr = Algea.cacheAlgea[kindName];
        if (tempAlgeaArr.indexOf(algea) == -1)
            tempAlgeaArr.push(algea);
    };
    return Algea;
}(egret.Sprite));
/**
 * 浮游物对象池
 */
Algea.cacheAlgea = {};
__reflect(Algea.prototype, "Algea");
// TypeScript file
var ThornSplit = (function () {
    function ThornSplit() {
    }
    ThornSplit.splitAction = function (weight, circle, tha) {
        var i = 0;
        var j;
        //临时球球对象
        var cir = circle;
        //返回的球球数组
        var cirArr = [];
        for (j = 0; j < 8; j++) {
            var newCir = Circle.produce(weight / 8, cir.cirName, cir.color, cir.name);
            //newCir.bulk = cir.radius/4;
            newCir.x = cir.x;
            newCir.y = cir.y;
            if (cirArr.indexOf(newCir) == -1)
                cirArr.push(newCir);
            tha.addChild(newCir);
        }
        //console.log(cirArr.length);
        // for(i = 0 ; i < 4; i++){
        while (i < 8) {
            cir = cirArr[i];
            //console.log("分裂第"+ i + "次");
            if (i == 0) {
                egret.Tween.get(cir).to({ x: cir.x + 0, y: cir.y - circle.radius * 4 }, 800, egret.Ease.sineIn);
            }
            if (i == 1) {
                egret.Tween.get(cir).to({ x: cir.x - circle.radius * 4, y: cir.y + 0 }, 800, egret.Ease.sineIn);
            }
            if (i == 2) {
                egret.Tween.get(cir)
                    .to({ x: cir.x + 0, y: cir.y + circle.radius * 4 }, 800, egret.Ease.sineIn);
            }
            if (i == 3) {
                egret.Tween.get(cir)
                    .to({ x: cir.x + circle.radius * 4, y: cir.y + 0 }, 800, egret.Ease.sineIn);
            }
            if (i == 4) {
                egret.Tween.get(cir)
                    .to({ x: cir.x + circle.radius * 2.9, y: cir.y + circle.radius * 2.9 }, 800, egret.Ease.sineIn);
            }
            if (i == 5) {
                egret.Tween.get(cir)
                    .to({ x: cir.x - circle.radius * 2.9, y: cir.y + circle.radius * 2.9 }, 800, egret.Ease.sineIn);
            }
            if (i == 6) {
                egret.Tween.get(cir)
                    .to({ x: cir.x - circle.radius * 2.9, y: cir.y - circle.radius * 2.9 }, 800, egret.Ease.sineIn);
            }
            if (i == 7) {
                egret.Tween.get(cir)
                    .to({ x: cir.x + circle.radius * 2.9, y: cir.y - circle.radius * 2.9 }, 800, egret.Ease.sineIn);
            }
            i++;
        }
        //  }
        //cirArr中所有的圆要返回给gamepanel的圆数组中
        return cirArr;
    };
    return ThornSplit;
}());
__reflect(ThornSplit.prototype, "ThornSplit");
// TypeScript file
var GameOverPanel = (function (_super) {
    __extends(GameOverPanel, _super);
    function GameOverPanel() {
        var _this = _super.call(this) || this;
        _this.skinName = "GameOverPanelSkin";
        _this.init();
        return _this;
    }
    GameOverPanel.prototype.init = function () {
        var i;
        // this.restarGameBtn = new egret.TextField();
        // this.restarGameBtn.text = "不服，再来一次!";
        // this.restarGameBtn.x = GameManager.stage.stageWidth /2;
        // this.restarGameBtn.y = GameManager.stage.stageHeight /2;
        // this.restarGameBtn.touchEnabled = true;
        // this.addChild(this.restarGameBtn);
        // this.restarGameBtn.addEventListener(egret.TouchEvent.TOUCH_TAP,LayerManager.onTouch2,this);
        this.rankingList.x = 5;
        this.rankingList.y = 123;
        /**
         * 排名列表名字、体重赋值
         *
         */
        //alert(this.allList.source[1].排名);
        for (i = 0; i < 10; i++) {
            if (i == 0) {
                this.allList.source[i].体重 = LayerManager.gameControl.myCirWeight + "kg";
                this.allList.source[i].名字 = LayerManager.gameControl.rankingArr[i];
                this.allList.source[i].吞噬 = LayerManager.game.myCirSwallowed;
            }
            else {
                this.allList.source[i].体重 = LayerManager.game.bootCirArr[i - 1].weight + "kg";
                this.allList.source[i].名字 = LayerManager.gameControl.rankingArr[i];
                this.allList.source[i].吞噬 = LayerManager.game.bootCirArr[i - 1].swallowed;
            }
        }
    };
    return GameOverPanel;
}(eui.Component));
__reflect(GameOverPanel.prototype, "GameOverPanel");
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-present, Egret Technology.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var LoadingUI = (function (_super) {
    __extends(LoadingUI, _super);
    function LoadingUI() {
        var _this = _super.call(this) || this;
        _this.createView();
        return _this;
    }
    LoadingUI.prototype.createView = function () {
        this.textField = new egret.TextField();
        this.addChild(this.textField);
        this.textField.y = 300;
        this.textField.width = 480;
        this.textField.height = 100;
        this.textField.textAlign = "center";
    };
    LoadingUI.prototype.setProgress = function (current, total) {
        this.textField.text = "Loading..." + current + "/" + total;
    };
    return LoadingUI;
}(egret.Sprite));
__reflect(LoadingUI.prototype, "LoadingUI");
var Main = (function (_super) {
    __extends(Main, _super);
    function Main() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isThemeLoadEnd = false;
        _this.isResourceLoadEnd = false;
        return _this;
    }
    Main.prototype.createChildren = function () {
        _super.prototype.createChildren.call(this);
        //inject the custom material parser
        //注入自定义的素材解析器
        var assetAdapter = new AssetAdapter();
        egret.registerImplementation("eui.IAssetAdapter", assetAdapter);
        egret.registerImplementation("eui.IThemeAdapter", new ThemeAdapter());
        //Config loading process interface
        //设置加载进度界面
        this.loadingView = new LoadingUI();
        this.stage.addChild(this.loadingView);
        // initialize the Resource loading library
        //初始化Resource资源加载库
        RES.addEventListener(RES.ResourceEvent.CONFIG_COMPLETE, this.onConfigComplete, this);
        RES.loadConfig("resource/default.res.json", "resource/");
    };
    /**
     * 配置文件加载完成,开始预加载皮肤主题资源和preload资源组。
     * Loading of configuration file is complete, start to pre-load the theme configuration file and the preload resource group
     */
    Main.prototype.onConfigComplete = function (event) {
        RES.removeEventListener(RES.ResourceEvent.CONFIG_COMPLETE, this.onConfigComplete, this);
        // load skin theme configuration file, you can manually modify the file. And replace the default skin.
        //加载皮肤主题配置文件,可以手动修改这个文件。替换默认皮肤。
        var theme = new eui.Theme("resource/default.thm.json", this.stage);
        theme.addEventListener(eui.UIEvent.COMPLETE, this.onThemeLoadComplete, this);
        RES.addEventListener(RES.ResourceEvent.GROUP_COMPLETE, this.onResourceLoadComplete, this);
        RES.addEventListener(RES.ResourceEvent.GROUP_LOAD_ERROR, this.onResourceLoadError, this);
        RES.addEventListener(RES.ResourceEvent.GROUP_PROGRESS, this.onResourceProgress, this);
        RES.addEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR, this.onItemLoadError, this);
        RES.loadGroup("preload");
    };
    /**
     * 主题文件加载完成,开始预加载
     * Loading of theme configuration file is complete, start to pre-load the
     */
    Main.prototype.onThemeLoadComplete = function () {
        this.isThemeLoadEnd = true;
        this.createScene();
    };
    /**
     * preload资源组加载完成
     * preload resource group is loaded
     */
    Main.prototype.onResourceLoadComplete = function (event) {
        if (event.groupName == "preload") {
            this.stage.removeChild(this.loadingView);
            RES.removeEventListener(RES.ResourceEvent.GROUP_COMPLETE, this.onResourceLoadComplete, this);
            RES.removeEventListener(RES.ResourceEvent.GROUP_LOAD_ERROR, this.onResourceLoadError, this);
            RES.removeEventListener(RES.ResourceEvent.GROUP_PROGRESS, this.onResourceProgress, this);
            RES.removeEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR, this.onItemLoadError, this);
            this.isResourceLoadEnd = true;
            this.createScene();
        }
    };
    Main.prototype.createScene = function () {
        if (this.isThemeLoadEnd && this.isResourceLoadEnd) {
            this.startCreateScene();
        }
    };
    /**
     * 资源组加载出错
     *  The resource group loading failed
     */
    Main.prototype.onItemLoadError = function (event) {
        console.warn("Url:" + event.resItem.url + " has failed to load");
    };
    /**
     * 资源组加载出错
     * Resource group loading failed
     */
    Main.prototype.onResourceLoadError = function (event) {
        //TODO
        console.warn("Group:" + event.groupName + " has failed to load");
        //忽略加载失败的项目
        //ignore loading failed projects
        this.onResourceLoadComplete(event);
    };
    /**
     * preload资源组加载进度
     * loading process of preload resource
     */
    Main.prototype.onResourceProgress = function (event) {
        if (event.groupName == "preload") {
            this.loadingView.setProgress(event.itemsLoaded, event.itemsTotal);
        }
    };
    /**
     * 创建场景界面
     * Create scene interface
     */
    Main.prototype.startCreateScene = function () {
        LayerManager.init(this.stage);
    };
    return Main;
}(eui.UILayer));
__reflect(Main.prototype, "Main");
// TypeScript file
var GameManager = (function () {
    function GameManager() {
    }
    return GameManager;
}());
__reflect(GameManager.prototype, "GameManager");
// TypeScript file
var LayerManager = (function () {
    function LayerManager() {
    }
    LayerManager.prototype.sconstructor = function () {
    };
    LayerManager.init = function (stage) {
        GameManager.stage = stage;
        stage.addChild(this.alertLayer);
        stage.addChild(this.gameLayer);
        //this.fixScreen();
        //初始化欢迎面板
        this.welcome = new WelcomePanel();
        //var welcome : WelcomePanel = new WelcomePanel();
        LayerManager.gameLayer.addChild(this.welcome);
        this.welcome.gameStartBtn.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onTouch, this);
    };
    LayerManager.onTouch = function () {
        this.welcome.gameStartBtn.removeEventListener(egret.TouchEvent.TOUCH_TAP, this.onTouch, this);
        LayerManager.gameLayer.removeChild(this.welcome);
        this.game = new GamePanel();
        LayerManager.gameLayer.addChild(this.game);
        this.gameControl = new GameControl;
        LayerManager.gameLayer.addChild(this.gameControl);
    };
    //时间到的时候，或者我方球球被吃完执行
    LayerManager.onTouch2 = function () {
        this.gameOver = new GameOverPanel();
        LayerManager.gameLayer.addChild(this.gameOver);
        LayerManager.game.gameOver();
        LayerManager.gameLayer.removeChild(this.game);
        LayerManager.gameLayer.removeChild(this.gameControl);
        LayerManager.gameOver.returnHall.addEventListener(egret.TouchEvent.TOUCH_TAP, LayerManager.onTouch3, this);
    };
    LayerManager.onTouch3 = function () {
        LayerManager.gameOver.returnHall.removeEventListener(egret.TouchEvent.TOUCH_TAP, LayerManager.onTouch3, this);
        LayerManager.gameLayer.removeChild(LayerManager.gameOver);
        //this.game = null;
        // LayerManager.game  = new GamePanel;
        // LayerManager.gameLayer.addChild(LayerManager.game);
        // //this.gameControl = null;
        // LayerManager.gameControl = new GameControl;
        // LayerManager.gameLayer.addChild(LayerManager.gameControl);
        //初始化欢迎面板
        this.welcome = new WelcomePanel();
        //var welcome : WelcomePanel = new WelcomePanel();
        LayerManager.gameLayer.addChild(this.welcome);
        this.welcome.gameStartBtn.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onTouch, this);
    };
    LayerManager.fixScreen = function () {
        if (egret.Capabilities.isMobile) {
            GameManager.stage.scaleMode = egret.StageScaleMode.FIXED_WIDTH;
        }
        else {
            GameManager.stage.scaleMode = egret.StageScaleMode.SHOW_ALL;
        }
    };
    return LayerManager;
}());
LayerManager.alertLayer = new egret.Sprite;
LayerManager.gameLayer = new egret.Sprite;
__reflect(LayerManager.prototype, "LayerManager");
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-present, Egret Technology.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var ThemeAdapter = (function () {
    function ThemeAdapter() {
    }
    /**
     * 解析主题
     * @param url 待解析的主题url
     * @param compFunc 解析完成回调函数，示例：compFunc(e:egret.Event):void;
     * @param errorFunc 解析失败回调函数，示例：errorFunc():void;
     * @param thisObject 回调的this引用
     */
    ThemeAdapter.prototype.getTheme = function (url, compFunc, errorFunc, thisObject) {
        function onGetRes(e) {
            compFunc.call(thisObject, e);
        }
        function onError(e) {
            if (e.resItem.url == url) {
                RES.removeEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR, onError, null);
                errorFunc.call(thisObject);
            }
        }
        RES.addEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR, onError, null);
        RES.getResByUrl(url, onGetRes, this, RES.ResourceItem.TYPE_TEXT);
    };
    return ThemeAdapter;
}());
__reflect(ThemeAdapter.prototype, "ThemeAdapter", ["eui.IThemeAdapter"]);
// TypeScript file
var WelcomePanel = (function (_super) {
    __extends(WelcomePanel, _super);
    function WelcomePanel() {
        var _this = _super.call(this) || this;
        //列表是否展开了
        _this.isShow = false;
        _this.nameArr = ["没心没肺的智多星", "虎火柴棍", "闪耀的电灯泡", "不帅你报警", "吃货精灵", "超人黑蜘蛛", "不正经的大脸猫", "任性的牛仔", "闹钟你别闹", "骑士骨头"];
        _this.skinName = "WelcomePanelSkin";
        //alert(this.gameStartBtn);
        _this.init();
        return _this;
    }
    //开始游戏按钮
    // public  starGameBtn : egret.TextField;
    WelcomePanel.prototype.init = function () {
        //     this.starGameBtn = new egret.TextField();
        //     this.starGameBtn.text = "开始游戏";
        //     this.starGameBtn.x = GameManager.stage.stageWidth /2;
        //     this.starGameBtn.y = GameManager.stage.stageHeight /2;
        //     this.starGameBtn.touchEnabled = true;
        //     this.addChild(this.starGameBtn);
        //alert(this.nameInput);
        //this.nameInput.prompt = "leo"
        this.refreshBtn.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onTouch, this);
        this.topList.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onTouch2, this);
        this.buttomList.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onTouch3, this);
        this.list.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onTouch4, this);
        // console.log(this.listGroup);
        // this.listGroup.x = 100;
        // this.listGroup.x = 248;
        // this.listGroup.y = 249;
        //添加滚动条
        var scroller = new eui.Scroller();
        //  scroller.y = 400;
        scroller.height = 36 * 4;
        scroller.width = 276;
        scroller.viewport = this.list;
        this.scroller = scroller;
        this.scroller.x = 248;
        this.addChild(scroller);
        //  this.scroller.y = 249;
        // this.scroller.x = 248;
        //添加遮罩
        var spMask = new egret.Shape();
        spMask.graphics.beginFill(0x000000);
        spMask.graphics.drawRect(0, 0, 276, 144);
        spMask.graphics.endFill();
        this.spMask = spMask;
        this.spMask.x = 248;
        //  this.spMask.y = 249;
        this.addChild(spMask);
        this.scroller.mask = spMask;
        //this.addEventListener(egret.Event.ENTER_FRAME,this.gameViewUpdata,this);
        this.myCirName = this.gameName.text;
    };
    WelcomePanel.prototype.createChildren = function () {
        _super.prototype.createChildren.call(this);
        //alert(this.ListButton);
        this.spMask.y = this.ListButton.height + 213;
        //设置消失点坐标
        //this.posScrollerClose = this.scroller.y = -this.scroller.height ;
        this.posScrollerClose = 249 - 144;
        this.scroller.y = 249 - 144;
        this.ListButton.addEventListener(egret.TouchEvent.TOUCH_TAP, this.changeListType, this);
    };
    WelcomePanel.prototype.changeListType = function () {
        if (!this.isShow) {
            egret.Tween.get(this.scroller).to({ y: this.ListButton.height + 213 }, 300);
            this.isShow = true;
        }
        else {
            egret.Tween.get(this.scroller).to({ y: this.posScrollerClose }, 300);
            this.isShow = false;
        }
        //console.log(this.btn.y , this.scroller.y)
    };
    WelcomePanel.prototype.onTouch = function () {
        //alert(this.nameLabel);
        this.myCirName = this.gameName.text = this.nameArr[Math.floor(Math.random() * 10)];
    };
    WelcomePanel.prototype.onTouch2 = function () {
        if (this.topList.skinName == "topList") {
            this.topList.skinName = "topList2";
        }
        if (this.buttomList.skinName == "buttomList2") {
            this.buttomList.skinName = "buttomList";
        }
    };
    WelcomePanel.prototype.onTouch3 = function () {
        if (this.topList.skinName == "topList2") {
            this.topList.skinName = "topList";
        }
        if (this.buttomList.skinName == "buttomList") {
            this.buttomList.skinName = "buttomList2";
        }
    };
    WelcomePanel.prototype.onTouch4 = function (event) {
        //这里执行收回列表、获取点击的文字、替换掉按钮的文字
        if (event.target.parent.$children[1].text != undefined) {
            this.displayText.text = event.target.parent.$children[1].text;
        }
        if (this.isShow) {
            egret.Tween.get(this.scroller).to({ y: this.posScrollerClose }, 300);
            this.isShow = false;
        }
        console.log("你点击的是" + event.target.parent.$children[1].text);
    };
    WelcomePanel.prototype.gameViewUpdata = function () {
        //console.log(this.scroller.x,this.scroller.y);
    };
    return WelcomePanel;
}(eui.Component));
__reflect(WelcomePanel.prototype, "WelcomePanel");
